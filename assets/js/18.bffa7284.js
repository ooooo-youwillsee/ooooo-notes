(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{325:function(a,t,r){a.exports=r.p+"assets/img/02_01.d5eb53fe.png"},395:function(a,t,r){"use strict";r.r(t);var _=r(18),e=Object(_.a)({},(function(){var a=this,t=a.$createElement,_=a._self._c||t;return _("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[_("h2",{attrs:{id:"_1、kafka-术语"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1、kafka-术语"}},[a._v("#")]),a._v(" 1、Kafka 术语")]),a._v(" "),_("h3",{attrs:{id:"record（消息）"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#record（消息）"}},[a._v("#")]),a._v(" "),_("code",[a._v("Record")]),a._v("（消息）")]),a._v(" "),_("p",[a._v("Kafka 处理的主要对象。")]),a._v(" "),_("h3",{attrs:{id:"topic（主题）"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#topic（主题）"}},[a._v("#")]),a._v(" "),_("code",[a._v("Topic")]),a._v("（主题）")]),a._v(" "),_("p",[a._v("主题是承载消息的逻辑容器，在实际使用中多用来区分具体的业务。")]),a._v(" "),_("p",[a._v("你可以为每个业务、每个应用甚至是每类数据都创建专属的主题。")]),a._v(" "),_("h3",{attrs:{id:"partition（分区）"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#partition（分区）"}},[a._v("#")]),a._v(" "),_("code",[a._v("Partition")]),a._v("（分区）")]),a._v(" "),_("p",[a._v("一个有序不变的消息序列。每个主题下可以有多个分区。")]),a._v(" "),_("h3",{attrs:{id:"offset（消息位移）"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#offset（消息位移）"}},[a._v("#")]),a._v(" "),_("code",[a._v("Offset")]),a._v("（消息位移）")]),a._v(" "),_("p",[a._v("分区中每条消息的位置信息，是一个单调递增且不变的值。")]),a._v(" "),_("h3",{attrs:{id:"producer（生产者）"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#producer（生产者）"}},[a._v("#")]),a._v(" "),_("code",[a._v("Producer")]),a._v("（生产者）")]),a._v(" "),_("p",[a._v("向主题发布新消息的应用程序。")]),a._v(" "),_("h3",{attrs:{id:"consumer（消费者）"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#consumer（消费者）"}},[a._v("#")]),a._v(" "),_("code",[a._v("Consumer")]),a._v("（消费者）")]),a._v(" "),_("p",[a._v("从主题订阅新消息的应用程序。")]),a._v(" "),_("h3",{attrs:{id:"consumer-offset（消费者位移）"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#consumer-offset（消费者位移）"}},[a._v("#")]),a._v(" "),_("code",[a._v("Consumer Offset")]),a._v("（消费者位移）")]),a._v(" "),_("p",[a._v("消费者消费进度，每个消费者都有自己的消费者位移。")]),a._v(" "),_("h3",{attrs:{id:"consumer-group（消费者组）"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#consumer-group（消费者组）"}},[a._v("#")]),a._v(" "),_("code",[a._v("Consumer Group")]),a._v("（消费者组）")]),a._v(" "),_("p",[a._v("多个消费者实例共同组成的一个组，同时消费多个分区以实现高吞吐。")]),a._v(" "),_("h3",{attrs:{id:"rebalance-（重平衡）"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#rebalance-（重平衡）"}},[a._v("#")]),a._v(" "),_("code",[a._v("Rebalance")]),a._v(" （重平衡）")]),a._v(" "),_("p",[a._v("消费者组内某个消费者实例挂掉后，其他消费者实例自动重新分配订阅主题分区的过程。")]),a._v(" "),_("p",[_("code",[a._v("Rebalance")]),a._v(" 是 Kafka 消费者端实现高可用的重要手段。")]),a._v(" "),_("p",[_("img",{attrs:{src:r(325),alt:"概念图"}})]),a._v(" "),_("h2",{attrs:{id:"_2、kafka-三层消息架构"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2、kafka-三层消息架构"}},[a._v("#")]),a._v(" 2、Kafka 三层消息架构")]),a._v(" "),_("ol",[_("li",[a._v("第一层是主题层，每个主题可以配置 M 个分区，而每个分区又可以配置 N 个副本。")]),a._v(" "),_("li",[a._v("第二层是分区层，每个分区的 N 个副本中只能有一个充当领导者角色，对外提供服务；其他 N-1 个副本是追随者副本，只是提供数据冗余之用。")]),a._v(" "),_("li",[a._v("第三层是消息层，分区中包含若干条消息，每条消息的位移从 0 开始，依次递增。")]),a._v(" "),_("li",[a._v("最后，客户端程序只能与分区的领导者副本进行交互。")])]),a._v(" "),_("h2",{attrs:{id:"_3、kafka-持久化数据"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3、kafka-持久化数据"}},[a._v("#")]),a._v(" 3、Kafka 持久化数据")]),a._v(" "),_("p",[a._v("Kafka 使用消息日志（Log）来保存数据，消息日志只能追加写入，所以避免了随机 I/O 操作，改为性能较好的顺序 I/O 写操作。")]),a._v(" "),_("p",[a._v("在 Kafka 底层，一个日志会细分成多个日志段，消息被追加写到当前最新的日志段中，当写满了一个日志段后，Kafka 会自动切分出一个新的日志段，并将老的日志段封存起来。Kafka 在后台还有定时任务会定期地检查老的日志段是否能够被删除，从而实现回收磁盘空间的目的。")])])}),[],!1,null,null,null);t.default=e.exports}}]);