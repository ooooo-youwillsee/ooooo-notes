(window.webpackJsonp=window.webpackJsonp||[]).push([[36],{397:function(_,v,t){"use strict";t.r(v);var a=t(18),s=Object(a.a)({},(function(){var _=this,v=_.$createElement,t=_._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("h2",{attrs:{id:"_1、配置"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1、配置"}},[_._v("#")]),_._v(" 1、配置")]),_._v(" "),t("h3",{attrs:{id:"_1、建立复制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1、建立复制"}},[_._v("#")]),_._v(" 1、建立复制")]),_._v(" "),t("p",[t("strong",[_._v("建立复制前会删除全部数据。")])]),_._v(" "),t("p",[_._v("配置复制的方式有三种；")]),_._v(" "),t("ol",[t("li",[_._v("配置文件中加入 "),t("code",[_._v("slaveof {masterHost} {masterPort}")]),_._v("。")]),_._v(" "),t("li",[_._v("redis 启动命令后加入 "),t("code",[_._v("slaveof {masterHost} {masterPort}")]),_._v("。")]),_._v(" "),t("li",[_._v("直接执行命令 "),t("code",[_._v("slaveof {masterHost} {masterPort}")]),_._v("。")])]),_._v(" "),t("h3",{attrs:{id:"_2、断开复制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2、断开复制"}},[_._v("#")]),_._v(" 2、断开复制")]),_._v(" "),t("p",[_._v("在从节点执行命令 "),t("code",[_._v("slaveof no one")]),_._v(" 来断开复制。所谓切主操作，就是先"),t("strong",[_._v("断开复制")]),_._v("，然后再"),t("strong",[_._v("建立复制")]),_._v("。")]),_._v(" "),t("h3",{attrs:{id:"_3、安全性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3、安全性"}},[_._v("#")]),_._v(" 3、安全性")]),_._v(" "),t("p",[_._v("为了安全性，一般都会在主节点上设置 "),t("code",[_._v("requirepass 123456")]),_._v("，所有客户端访问必须使用 "),t("code",[_._v("auth 123456")]),_._v(" 验证。因此从节点开启复制时，也要设置 "),t("code",[_._v("masterauth 123456")]),_._v("。")]),_._v(" "),t("h3",{attrs:{id:"_4、只读"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4、只读"}},[_._v("#")]),_._v(" 4、只读")]),_._v(" "),t("p",[_._v("默认情况下，从节点使用 "),t("code",[_._v("slave-read-only=yes")]),_._v(" 配置为只读模式。由于已经开启了复制，建议从节点保持"),t("strong",[_._v("只读")]),_._v("模式。")]),_._v(" "),t("h3",{attrs:{id:"_5、传输延迟"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5、传输延迟"}},[_._v("#")]),_._v(" 5、传输延迟")]),_._v(" "),t("p",[_._v("主从节点之间复制数据，肯定会有延迟。")]),_._v(" "),t("p",[_._v("redis 提供了 "),t("code",[_._v("repl-disable-tcp-nodelay")]),_._v(" 参数用于关闭 "),t("strong",[_._v("TCP_NODELAY")]),_._v("，默认关闭。")]),_._v(" "),t("ul",[t("li",[_._v("当关闭时，主节点的数据无论大小都会发送到从节点，这样就降低了延迟，但增加了带宽。")]),_._v(" "),t("li",[_._v("当开启时，主节点会合并较小的 TCP 数据包，从而节省带宽。")])]),_._v(" "),t("h2",{attrs:{id:"_2、拓扑"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2、拓扑"}},[_._v("#")]),_._v(" 2、拓扑")]),_._v(" "),t("p",[_._v("主要有三种；"),t("strong",[_._v("一主一从")]),_._v("，"),t("strong",[_._v("一主多从")]),_._v("，"),t("strong",[_._v("树状主从")]),_._v("。")]),_._v(" "),t("ul",[t("li",[_._v("一主一从： 最简单的结构，一般只在 从节点上开启 AOF 操作。")]),_._v(" "),t("li",[_._v("一主多从： 用于读多写少、读写分离的场景")]),_._v(" "),t("li",[_._v("树状主从： 从节点不但可以复制主节点的数据，还可以作为其他的节点的主节点。")])]),_._v(" "),t("h2",{attrs:{id:"_3、原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3、原理"}},[_._v("#")]),_._v(" 3、原理")]),_._v(" "),t("h3",{attrs:{id:"_1、复制过程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1、复制过程"}},[_._v("#")]),_._v(" 1、复制过程")]),_._v(" "),t("ol",[t("li",[_._v("执行 "),t("code",[_._v("slaveof {masterHost} {masterPort}")]),_._v(" 命令后，保存主节点信息。")]),_._v(" "),t("li",[_._v("从节点每秒运行定时任务维护复制逻辑，当发现新的主节点后，建立连接。")]),_._v(" "),t("li",[_._v("发送 ping 命令，主要是检查网络是否可用和是否可以处理命令（可能主节点阻塞了）。")]),_._v(" "),t("li",[_._v("权限验证，"),t("code",[_._v("requirepass")]),_._v(" 和 "),t("code",[_._v("masterauth")]),_._v(" 是否匹配。")]),_._v(" "),t("li",[_._v("同步数据集，分为"),t("strong",[_._v("全量同步")]),_._v("和"),t("strong",[_._v("部分同步")]),_._v("。")]),_._v(" "),t("li",[_._v("命令持续复制，新的命令持续发给从节点。")])]),_._v(" "),t("h3",{attrs:{id:"_2、数据同步"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2、数据同步"}},[_._v("#")]),_._v(" 2、数据同步")]),_._v(" "),t("p",[_._v("同步过程分为"),t("strong",[_._v("全量复制")]),_._v("和"),t("strong",[_._v("部分复制")]),_._v("。")]),_._v(" "),t("ol",[t("li",[_._v("参与主从复制的节点都会维护自身复制偏移量。命令 "),t("code",[_._v("info")]),_._v(" 中 "),t("code",[_._v("master_repl_offset")]),_._v(" 和 "),t("code",[_._v("slave_repl_offset")]),_._v(" 。")]),_._v(" "),t("li",[_._v("复制积压缓冲区，主节点把命令发送从节点，还会把命令写入"),t("strong",[_._v("复制积压缓冲区")]),_._v("，这个用于"),t("strong",[_._v("部分复制和命令丢失的场景")]),_._v("。命令 "),t("code",[_._v("info")]),_._v(" 中 "),t("code",[_._v("repl_backlog_*")]),_._v("。")]),_._v(" "),t("li",[_._v("主节点运行 ID，用来唯一识别 Redis 节点，当运行 ID 变化了，从节点将做全量复制了。节点重启了，运行 ID 也会变化。可以执行命令 "),t("code",[_._v("debug reload")]),_._v(" 来重新加载并保持运行 ID 不变，但是会阻塞当前 Redis。 命令 "),t("code",[_._v("info")]),_._v(" 中 "),t("code",[_._v("run_id")]),_._v("。")])]),_._v(" "),t("h3",{attrs:{id:"_3、全量复制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3、全量复制"}},[_._v("#")]),_._v(" 3、全量复制")]),_._v(" "),t("h3",{attrs:{id:"_4、部分复制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4、部分复制"}},[_._v("#")]),_._v(" 4、部分复制")]),_._v(" "),t("h3",{attrs:{id:"_5、心跳"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5、心跳"}},[_._v("#")]),_._v(" 5、心跳")]),_._v(" "),t("h3",{attrs:{id:"_6、异步复制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6、异步复制"}},[_._v("#")]),_._v(" 6、异步复制")]),_._v(" "),t("h2",{attrs:{id:"_4、开发与运维中的问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4、开发与运维中的问题"}},[_._v("#")]),_._v(" 4、开发与运维中的问题")])])}),[],!1,null,null,null);v.default=s.exports}}]);