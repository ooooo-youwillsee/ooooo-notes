(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{384:function(_,v,t){_.exports=t.p+"assets/img/07_01.851a9135.png"},385:function(_,v,t){_.exports=t.p+"assets/img/07_02.7905b49f.png"},465:function(_,v,t){"use strict";t.r(v);var e=t(25),o=Object(e.a)({},(function(){var _=this,v=_.$createElement,e=_._self._c||v;return e("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[e("h2",{attrs:{id:"_1、行锁"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1、行锁"}},[_._v("#")]),_._v(" 1、行锁")]),_._v(" "),e("blockquote",[e("p",[_._v("MySQL 的行锁是在引擎层由各个引擎自己实现的，并不是所有的引擎都支持行锁，比如 MyISAM 引擎就不支持，InnoDB 引擎支持行锁。")])]),_._v(" "),e("p",[_._v("两阶段锁：")]),_._v(" "),e("p",[e("img",{attrs:{src:t(384),alt:"两阶段锁例子"}})]),_._v(" "),e("p",[_._v("实际上事务B的 update 语句会被阻塞，直到事务A执行 commit 之后，事务B才能继续执行。")]),_._v(" "),e("p",[e("strong",[_._v("在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议。")])]),_._v(" "),e("p",[_._v("如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。")]),_._v(" "),e("p",[_._v("比如，电影票在线交易业务：")]),_._v(" "),e("ol",[e("li",[_._v("从顾客A账户余额中扣除电影票价。")]),_._v(" "),e("li",[_._v("给影院B的账户余额增加这张电影票价。")]),_._v(" "),e("li",[_._v("记录一条交易日志。")])]),_._v(" "),e("p",[_._v("要保证交易的原子性，就要把这三个操作放在一个事务中，按照 "),e("strong",[_._v("3 -> 1 -> 2")]),_._v(" 的顺序执行，就减少了事务之间的锁等待，提升了并发度。")]),_._v(" "),e("h2",{attrs:{id:"_2、死锁和死锁检测"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2、死锁和死锁检测"}},[_._v("#")]),_._v(" 2、死锁和死锁检测")]),_._v(" "),e("p",[_._v("死锁例子：")]),_._v(" "),e("p",[e("img",{attrs:{src:t(385),alt:"死锁例子"}})]),_._v(" "),e("p",[_._v("事务A在等待事务B释放 id=2 的行锁，而事务B在等待事务A释放 id=1 的行锁。 事务A和事务B在互相等待对方的资源释放，就是进入了死锁状态。")]),_._v(" "),e("p",[_._v("当出现死锁以后，有两种策略")]),_._v(" "),e("ol",[e("li",[_._v("直接进入等待，直到超时，这个超时时间通过参数 "),e("code",[_._v("innodb_lock_wait_timeout")]),_._v(" 来设置。")]),_._v(" "),e("li",[_._v("发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。通过参数 "),e("code",[_._v("innodb_deadlock_detect")]),_._v(" 设置为 on。")])]),_._v(" "),e("p",[_._v("在 InnoDB 中，"),e("code",[_._v("innodb_lock_wait_timeout")]),_._v(" 的默认值是 50s，当出现死锁以后，第一个被锁住的线程要过 50s 才会超时退出，这个等待时间肯定是无法接受的，但如果设置为 1s，可能出现不是死锁的情况（大事务），造成误伤。")]),_._v(" "),e("p",[_._v("正常情况下，我们要采用第二种策略："),e("strong",[_._v("主动死锁检测")]),_._v("。"),e("code",[_._v("innodb_deadlock_detect")]),_._v(" 的默认值为 on。")]),_._v(" "),e("p",[_._v("当更新同一行时，每个线程检查的时间复杂度为 O(n), 也就是说 1000 个线程，要操作 100w 次，所以死锁检测要耗费大量的 CPU 资源。")]),_._v(" "),e("p",[_._v("怎么解决由这种热点行更新导致的性能问题呢？")]),_._v(" "),e("ul",[e("li",[e("p",[_._v("一种头痛医头的方法，就是如果你能确保这个业务一定不会出现死锁，可以临时把死锁检测关掉。"),e("strong",[_._v("业务有损。")])])]),_._v(" "),e("li",[e("p",[_._v("控制并发度。比如同一行同时最多只有 10 个线程在更新，那么死锁检测的成本很低，就不会出现这个问题。")])])]),_._v(" "),e("p",[_._v("并发控制要做在数据库服务端，如果你有中间件，可以考虑在中间件实现；如果你的团队有能修改 MySQL 源码的人，也可以做在 MySQL 里面。基本思路就是，对于相同行的更新，在进入引擎之前排队。这样在 InnoDB 内部就不会有大量的死锁检测工作了。")]),_._v(" "),e("p",[e("strong",[_._v("控制并发度也可以从业务设计上优化。考虑将一行改成逻辑上的多行来减少锁冲突。")])]),_._v(" "),e("p",[_._v("还是以影院账户为例，可以考虑放在多条记录上，比如 10 个记录，影院的账户总额等于这 10 个记录的值的总和。这样每次要给影院账户加金额的时候，随机选其中一条记录来加。这样每次冲突概率变成原来的 1/10，可以减少锁等待个数，也就减少了死锁检测的 CPU 消耗。")]),_._v(" "),e("p",[_._v("如果账户余额可能会减少，比如退票逻辑，那么这时候就需要考虑当一部分行记录变成 0 的时候，代码要有特殊处理。")]),_._v(" "),e("h2",{attrs:{id:"_3、问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3、问题"}},[_._v("#")]),_._v(" 3、问题")]),_._v(" "),e("p",[_._v("如果你要删除一个表里面的前 10000 行数据，有以下三种方法可以做到：")]),_._v(" "),e("ul",[e("li",[_._v("第一种，直接执行 "),e("code",[_._v("delete from T limit 10000")]),_._v(";")]),_._v(" "),e("li",[_._v("第二种，在一个连接中循环执行20次 "),e("code",[_._v("delete from T limit 500")]),_._v(";")]),_._v(" "),e("li",[_._v("第三种，在 20 个连接中同时执行 "),e("code",[_._v("delete from T limit 500")]),_._v("。")])]),_._v(" "),e("p",[_._v("你会选择哪一种方法呢？为什么呢？")]),_._v(" "),e("p",[_._v("第二种方式是相对较好的。")]),_._v(" "),e("p",[_._v("第一种方式单个语句占用时间长，锁的时间也比较长；而且大事务还会导致主从延迟。")]),_._v(" "),e("p",[_._v("第三种方式会人为造成锁冲突。")])])}),[],!1,null,null,null);v.default=o.exports}}]);