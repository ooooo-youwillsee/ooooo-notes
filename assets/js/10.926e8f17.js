(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{396:function(e,_,r){e.exports=r.p+"assets/img/09_01.05866a57.png"},397:function(e,_,r){e.exports=r.p+"assets/img/09_02.3562164a.png"},398:function(e,_,r){e.exports=r.p+"assets/img/09_03.495de06e.png"},468:function(e,_,r){"use strict";r.r(_);var v=r(25),t=Object(v.a)({},(function(){var e=this,_=e.$createElement,v=e._self._c||_;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("h2",{attrs:{id:"_1、查询过程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1、查询过程"}},[e._v("#")]),e._v(" 1、查询过程")]),e._v(" "),v("p",[e._v("主键索引 ID 和 普通索引 K:")]),e._v(" "),v("p",[v("img",{attrs:{src:r(396),alt:"索引树"}})]),e._v(" "),v("p",[e._v("假设执行查询的语句是 "),v("code",[e._v("select id from T where k=5")]),e._v(", 使用"),v("strong",[e._v("二分法")]),e._v("查询：")]),e._v(" "),v("ul",[v("li",[e._v("对于普通索引来说，查找到满足条件的第一个记录(5,500)后，需要查找下一个记录，直到碰到第一个不满足 k=5 条件的记录。")]),e._v(" "),v("li",[e._v("对于唯一索引来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继续检索。")])]),e._v(" "),v("p",[v("strong",[e._v("两个索引的性能差别，微乎其微。")])]),e._v(" "),v("p",[e._v("InnoDB 的数据是按数据页为单位来读写，也就是说，当找到 k=5 的记录的时候，它所在的数据页就都在内存里了，所以判断下一条记录是很快的。")]),e._v(" "),v("h2",{attrs:{id:"_2、更新过程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2、更新过程"}},[e._v("#")]),e._v(" 2、更新过程")]),e._v(" "),v("p",[e._v("当需要更新一个数据页时，如果数据页在内存中就直接更新，如果这个数据页还没有在内存中，在不影响数据一致性的前提下，InooDB 会将这些更新操作缓存在 "),v("strong",[e._v("change buffer")]),e._v(" 中，这样就不需要从磁盘中读入这个数据页了。在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行 "),v("strong",[e._v("change buffer")]),e._v(" 中与这个页有关的操作。通过这种方式就能保证这个数据逻辑的正确性。")]),e._v(" "),v("p",[e._v("将 "),v("strong",[e._v("change buffer")]),e._v(" 中的操作应用到原数据页，得到最新结果的过程称为 "),v("strong",[e._v("merge")]),e._v("。除了访问这个数据页会触发 "),v("strong",[e._v("merge")]),e._v(" 外，系统有后台线程会定期 "),v("strong",[e._v("merge")]),e._v(" 。在数据库正常关闭（shutdown）的过程中，也会执行 "),v("strong",[e._v("merge")]),e._v(" 操作。")]),e._v(" "),v("p",[e._v("对于"),v("strong",[e._v("唯一索引")]),e._v("来说，所有的更新操作都要先判断这个操作是否违反唯一性约束，所以必须要将数据页读入内存才能判断，这时 "),v("strong",[e._v("change buffer")]),e._v(" 不能使用了。")]),e._v(" "),v("p",[v("strong",[e._v("change buffer")]),e._v(" 用的是 "),v("strong",[e._v("buffer pool")]),e._v(" 里的内存，因此不能无限增大。"),v("strong",[e._v("change buffer")]),e._v(" 的大小，可以通过参数 "),v("code",[e._v("innodb_change_buffer_max_size")]),e._v(" 来动态设置。这个参数设置为 50 的时候，表示 "),v("strong",[e._v("change buffer")]),e._v(" 的大小最多只能占用 "),v("strong",[e._v("buffer pool")]),e._v(" 的 50%。")]),e._v(" "),v("h2",{attrs:{id:"_3、change-buffer-的使用场景"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3、change-buffer-的使用场景"}},[e._v("#")]),e._v(" 3、change buffer 的使用场景")]),e._v(" "),v("p",[v("strong",[e._v("change buffer")]),e._v(" 的主要目的就是将记录的变更动作缓存下来，所以在一个数据页做 merge 之前，"),v("strong",[e._v("change buffer")]),e._v(" 记录的变更越多（也就是这个页面上要更新的次数越多），收益就越大。")]),e._v(" "),v("p",[v("strong",[e._v("对于写多读少的业务来说， change buffer 的使用效果最好。这种业务模型常见的就是账单类、日志类的系统。")])]),e._v(" "),v("p",[e._v("假设一个业务的更新模式是写入之后马上会做查询，那么即使满足了条件，将更新先记录在 "),v("strong",[e._v("change buffer")]),e._v("，但之后由于马上要访问这个数据页，会立即触发 "),v("strong",[e._v("merge")]),e._v(" 过程。这样随机访问 IO 的次数不会减少，反而增加了 "),v("strong",[e._v("change buffer")]),e._v(" 的维护代价。")]),e._v(" "),v("h2",{attrs:{id:"_4、索引选择和实践"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4、索引选择和实践"}},[e._v("#")]),e._v(" 4、索引选择和实践")]),e._v(" "),v("p",[e._v("在不影响业务的情况下，建议你尽量选择普通索引。")]),e._v(" "),v("p",[e._v("普通索引和 "),v("strong",[e._v("change buffer")]),e._v(" 的配合使用，对于数据量大的表的更新优化还是很明显的。")]),e._v(" "),v("h2",{attrs:{id:"_5、change-buffer-和-redo-log"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5、change-buffer-和-redo-log"}},[e._v("#")]),e._v(" 5、change buffer 和 redo log")]),e._v(" "),v("p",[e._v("执行插入语句：")]),e._v(" "),v("div",{staticClass:"language-shell script extra-class"},[v("pre",{pre:!0,attrs:{class:"language-shell"}},[v("code",[e._v("mysql"),v("span",{pre:!0,attrs:{class:"token operator"}},[e._v(">")]),e._v(" insert into t"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("id,k"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" values"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("id1,k1"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(","),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("id2,k2"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n")])])]),v("p",[e._v("我们假设\b当前 k 索引树的状态，查找到位置后，k1 所在的数据页在内存(InnoDB buffer pool)中，k2 所在的数据页不在内存中。下图是带 "),v("strong",[e._v("change buffer")]),e._v(" 的更新状态图。")]),e._v(" "),v("p",[v("img",{attrs:{src:r(397),alt:"带change buffer的更新过程"}})]),e._v(" "),v("p",[e._v("这条插入语句做了如下的操作:")]),e._v(" "),v("ol",[v("li",[e._v("Page 1 在内存中，直接更新内存。")]),e._v(" "),v("li",[e._v("Page 2 没有在内存中，就在内存的 "),v("strong",[e._v("change buffer")]),e._v(' 区域，记录下"我要往 Page 2 插入一行"这个信息。')]),e._v(" "),v("li",[e._v("将上述两个动作记入 redo log 中（图中3和4）。")])]),e._v(" "),v("p",[e._v("图中的两个虚线箭头，是后台操作，不影响更新的响应时间。")]),e._v(" "),v("p",[e._v("现在要执行语句 "),v("code",[e._v("select * from t where k in (k1, k2)")]),e._v("，这两个读请求的流程图：")]),e._v(" "),v("p",[v("img",{attrs:{src:r(398),alt:"带change buffer的读过程"}})]),e._v(" "),v("ol",[v("li",[e._v("读 Page 1 的时候，直接从内存返回。")]),e._v(" "),v("li",[e._v("要读 Page 2 的时候，需要把 Page 2 从磁盘读入内存中，然后应用 "),v("strong",[e._v("change buffer")]),e._v(" 里面的操作日志，生成一个正确的版本并返回结果。")])]),e._v(" "),v("p",[e._v("从上图可知，"),v("strong",[e._v("redo log 主要节省的是随机写磁盘的 IO 消耗（转成顺序写），而 "),v("strong",[e._v("change buffer")]),e._v(" 主要节省的则是随机读磁盘的 IO 消耗。")])]),e._v(" "),v("h2",{attrs:{id:"_6、问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_6、问题"}},[e._v("#")]),e._v(" 6、问题")]),e._v(" "),v("p",[e._v("change buffer 一开始是写内存的，那么如果这个时候机器掉电重启，会不会导致 change buffer 丢失呢？change buffer 丢失可不是小事儿，再从磁盘读入数据可就没有了 merge 过程，就等于是数据丢失了。会不会出现这种情况呢？")]),e._v(" "),v("p",[e._v("不会丢失。虽然是只更新内存，但是在事务提交的时候，我们把 change buffer 的操作也记录到 redo log 里了，所以崩溃恢复的时候，change buffer 也能找回来。")]),e._v(" "),v("p",[e._v("merge 的执行流程是这样的：")]),e._v(" "),v("ul",[v("li",[e._v("从磁盘读入数据页到内存（老版本的数据页）；")]),e._v(" "),v("li",[e._v("从 change buffer 里找出这个数据页的 change buffer 记录(可能有多个），依次应用，得到新版数据页；")]),e._v(" "),v("li",[e._v("写 redo log。这个 redo log 包含了数据的变更和 change buffer 的变更。")])])])}),[],!1,null,null,null);_.default=t.exports}}]);