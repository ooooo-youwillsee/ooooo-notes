<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>线偶的IT笔记</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/</link><description>线偶的IT笔记</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>297872913@qq.com (线偶)</managingEditor><webMaster>297872913@qq.com (线偶)</webMaster><lastBuildDate>Sat, 13 Jul 2024 08:00:00 +0800</lastBuildDate><atom:link href="https://ooooo-youwillsee.github.io/ooooo-notes/index.xml" rel="self" type="application/rss+xml"/><item><title>16 CountDownLatch</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/16-countdownlatch/</link><pubDate>Sat, 13 Jul 2024 08:00:00 +0800</pubDate><author>线偶</author><guid>https://ooooo-youwillsee.github.io/ooooo-notes/16-countdownlatch/</guid><description>jdk 基于 8 版本 在平时的开发中，我们经常会用到 CountDownLatch, 它是用于线程通信的工具类。 使用方式</description></item><item><title>rust ffi</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/rust-ffi/</link><pubDate>Wed, 10 Jul 2024 08:00:00 +0800</pubDate><author>线偶</author><guid>https://ooooo-youwillsee.github.io/ooooo-notes/rust-ffi/</guid><description></description></item><item><title>rust 自定义 macro</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/rust-%E8%87%AA%E5%AE%9A%E4%B9%89-macro/</link><pubDate>Tue, 09 Jul 2024 08:00:00 +0800</pubDate><author>线偶</author><guid>https://ooooo-youwillsee.github.io/ooooo-notes/rust-%E8%87%AA%E5%AE%9A%E4%B9%89-macro/</guid><description><![CDATA[实现一个 json! 实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #[derive(Debug, PartialEq)] pub enum Json { Null, Number(f64), Str(String), Array(Vec&lt;Json&gt;), Object(HashMap&lt;String, Json&gt;), } impl From&lt;String&gt; for Json { fn]]></description></item><item><title>sso 登录流程</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/sso-%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B/</link><pubDate>Fri, 28 Jun 2024 08:00:00 +0800</pubDate><author>线偶</author><guid>https://ooooo-youwillsee.github.io/ooooo-notes/sso-%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B/</guid><description>先介绍 OAuth2 的授权码，然后再介绍 SSO 的流程。这里的代码来自 Sa-Token。 OAuth2 授权码模式 授权码模式，涉及到两个接口，获取 code和获取 access</description></item><item><title>mybatis-plus 打印日志</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/mybatis-plus-%E6%89%93%E5%8D%B0%E6%97%A5%E5%BF%97/</link><pubDate>Thu, 27 Jun 2024 08:00:00 +0800</pubDate><author>线偶</author><guid>https://ooooo-youwillsee.github.io/ooooo-notes/mybatis-plus-%E6%89%93%E5%8D%B0%E6%97%A5%E5%BF%97/</guid><description>在 spring boot 打印日志 application.yaml: 1 2 3 4 5 6 7 mybatis-plus: configuration: log-impl: org.apache.ibatis.logging.slf4j.Slf4jImpl logging: level: com.ooooo.dao.mapper: debug 参考 spring boot logging 原理 源码位置: org.apache.ibatis.mapping.MappedStatement.Builder#Builder 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public Builder(Configuration configuration, String id, SqlSource sqlSource, SqlCommandType sqlCommandType) { mappedStatement.configuration = configuration; mappedStatement.id =</description></item><item><title>12 LinkedBlockingQueue</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/12-linkedblockingqueue/</link><pubDate>Wed, 26 Jun 2024 08:00:00 +0800</pubDate><author>线偶</author><guid>https://ooooo-youwillsee.github.io/ooooo-notes/12-linkedblockingqueue/</guid><description>jdk 基于 8 版本 在平时的开发中，我们经常会用到 LinkedBlockingQueue, 它是基于链表来实现的，是并发安全的。 与 ArrayBlockingQueue 相比，LinkedBlockingQueue 的性能会更高</description></item><item><title>14 AtomicInteger</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/14-atomicinteger/</link><pubDate>Wed, 26 Jun 2024 08:00:00 +0800</pubDate><author>线偶</author><guid>https://ooooo-youwillsee.github.io/ooooo-notes/14-atomicinteger/</guid><description>jdk 基于 8 版本 在平时的开发中，我们经常会用到 AtomicInteger, 它是原子计数，与之类似的还有很多，比如 AtomicBoolean, AtomicLong, AtomicReferenceFieldUpdater</description></item><item><title>11 ArrayBlockingQueue</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/11-arrayblockingqueue/</link><pubDate>Tue, 25 Jun 2024 08:00:00 +0800</pubDate><author>线偶</author><guid>https://ooooo-youwillsee.github.io/ooooo-notes/11-arrayblockingqueue/</guid><description><![CDATA[jdk 基于 8 版本 在平时的开发中，我们可能会用到 ArrayBlockingQueue, 它是基于循环数组来实现的，是并发安全的。 使用方式 1 2 3 4 5 6 7 8 9 public class ArrayBlockingQueueTest { @Test void test() { BlockingQueue&lt;String&gt; queue = new ArrayBlockingQueue&lt;&gt;(10); queue.offer(&#34;1&#34;); assertThat(queue.poll()).isEqualTo(&#34;1&#34;);]]></description></item><item><title>rust axum 测试类</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/rust-axum-%E6%B5%8B%E8%AF%95%E7%B1%BB/</link><pubDate>Mon, 10 Jun 2024 08:00:00 +0800</pubDate><author>线偶</author><guid>https://ooooo-youwillsee.github.io/ooooo-notes/rust-axum-%E6%B5%8B%E8%AF%95%E7%B1%BB/</guid><description><![CDATA[multipart 测试类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 const BOUNDARY: &amp;str = &#34;BOUNDARY&#34;; #[tokio::test] async fn test_import_proc_def() -&gt; anyhow::Result&lt;()&gt; { let bytes = fs::read(&#34;./examples/test01.xml&#34;).await?; let request = Request::builder() .header( CONTENT_TYPE, format!(&#34;multipart/form-data; boundary={}&#34;, BOUNDARY), ) .body::&lt;Body&gt;(generate_multipart_data(&#34;file&#34;, &amp;bytes)?.into()) .unwrap(); let multipart = Multipart::from_request(request, &amp;State(())).await?;]]></description></item><item><title>rust openssl 依赖</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/rust-openssl-%E4%BE%9D%E8%B5%96/</link><pubDate>Sun, 09 Jun 2024 08:00:00 +0800</pubDate><author>线偶</author><guid>https://ooooo-youwillsee.github.io/ooooo-notes/rust-openssl-%E4%BE%9D%E8%B5%96/</guid><description>在 window 上使用 openssl, 会遇到错误 failed to run custom build command for openssl-sys v0.9.102. 解决方法 下载 vcpkg, 打开 powershell 执行 ./bootstrap-vcpkg.bat 执行 ./vcpkg.exe install openssl:x64-windows-static 配置环境变量 OPENSSL_DIR=C:\Users\ooooo\Development\Vcpkg\installed\x64-windows-static 重新启动项目编译 参考 stackoverflow github</description></item></channel></rss>