<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>线偶的IT笔记</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/</link><description>线偶的IT笔记</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>297872913@qq.com (线偶)</managingEditor><webMaster>297872913@qq.com (线偶)</webMaster><lastBuildDate>Fri, 12 Apr 2024 08:00:00 +0800</lastBuildDate><atom:link href="https://ooooo-youwillsee.github.io/ooooo-notes/index.xml" rel="self" type="application/rss+xml"/><item><title>简单实现 gossip 协议</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0-gossip-%E5%8D%8F%E8%AE%AE/</link><pubDate>Fri, 12 Apr 2024 08:00:00 +0800</pubDate><author>线偶</author><guid>https://ooooo-youwillsee.github.io/ooooo-notes/%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0-gossip-%E5%8D%8F%E8%AE%AE/</guid><description>gossip 协议是为实现最终一致性提出的。 实现思路 每个节点都有基本属性，如 id, addr, port。 每个节点都有成员列表 members，存储一部分数据 data。 通</description></item><item><title>04 RedissonSortedSet</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/04-redissonsortedset/</link><pubDate>Thu, 11 Apr 2024 08:00:00 +0800</pubDate><author>线偶</author><guid>https://ooooo-youwillsee.github.io/ooooo-notes/04-redissonsortedset/</guid><description>redisson 基于 org.redisson:redisson-spring-data-27:3.27.2 版本 在 java 中，操作 redis 一般都会选择 redisson 框架, 我们需要了解常用功能的实现原理, 这次来介绍 RedissonSortedSet。 使用方式 1 2 3 4</description></item><item><title>05 RedissonPriorityQueue</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/05-redissonpriorityqueue/</link><pubDate>Thu, 11 Apr 2024 08:00:00 +0800</pubDate><author>线偶</author><guid>https://ooooo-youwillsee.github.io/ooooo-notes/05-redissonpriorityqueue/</guid><description>redisson 基于 org.redisson:redisson-spring-data-27:3.27.2 版本 在 java 中，操作 redis 一般都会选择 redisson 框架, 我们需要了解常用功能的实现原理, 这次来介绍 RedissonPriorityQueue。 使用方式</description></item><item><title>03 RedissonMultiLock</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/03-redissonmultilock/</link><pubDate>Wed, 10 Apr 2024 08:00:00 +0800</pubDate><author>线偶</author><guid>https://ooooo-youwillsee.github.io/ooooo-notes/03-redissonmultilock/</guid><description>redisson 基于 org.redisson:redisson-spring-data-27:3.27.2 版本 在 java 中，操作 redis 一般都会选择 redisson 框架, 我们需要了解常用功能的实现原理, 这次来介绍 RedissonMultiLock。 使用方式 1 2 3 4</description></item><item><title>02 RedissonSpinLock</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/02-redissonspinlock/</link><pubDate>Tue, 09 Apr 2024 08:00:00 +0800</pubDate><author>线偶</author><guid>https://ooooo-youwillsee.github.io/ooooo-notes/02-redissonspinlock/</guid><description>redisson 基于 org.redisson:redisson-spring-data-27:3.27.2 版本 在 java 中，操作 redis 一般都会选择 redisson 框架, 我们需要了解常用功能的实现原理, 这次来介绍 RedissonSpinLock。 使用方式 1 2 3 4 5</description></item><item><title>01 RedissonLock</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/01-redissonlock/</link><pubDate>Mon, 08 Apr 2024 08:00:00 +0800</pubDate><author>线偶</author><guid>https://ooooo-youwillsee.github.io/ooooo-notes/01-redissonlock/</guid><description>redisson 基于 org.redisson:redisson-spring-data-27:3.27.2 版本 在 java 中，操作 redis 一般都会选择 redisson 框架, 我们需要了解常用功能的实现原理, 这次来介绍 RedissonLock。 使用方式 1 2 3 4 5 6 7 8 9</description></item><item><title>05 TreeMap</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/05-treemap/</link><pubDate>Wed, 03 Apr 2024 08:00:00 +0800</pubDate><author>线偶</author><guid>https://ooooo-youwillsee.github.io/ooooo-notes/05-treemap/</guid><description>jdk 基于 8 版本 在平时的开发中，我们很少会用到 TreeMap, 但是还是需要了解源码。 TreeMap 基于红黑树来实现按照 key 排序，关于这个算法，这里不做解释。 使用方式 1 2 3 4</description></item><item><title>04 LinkedHashMap</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/04-linkedhashmap/</link><pubDate>Tue, 02 Apr 2024 08:00:00 +0800</pubDate><author>线偶</author><guid>https://ooooo-youwillsee.github.io/ooooo-notes/04-linkedhashmap/</guid><description>jdk 基于 8 版本 在平时的开发中，我们会经常用到 LinkedHashMap, 非常有必要了解源码。 LinkedHashMap 基于 HashMap 来实现, 内部借助双向链表来维持访问顺序，可以用来实现 LRU 算法。 使用方式</description></item><item><title>03 HashMap</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/03-hashmap/</link><pubDate>Mon, 01 Apr 2024 08:00:00 +0800</pubDate><author>线偶</author><guid>https://ooooo-youwillsee.github.io/ooooo-notes/03-hashmap/</guid><description>jdk 基于 8 版本 在平时的开发中，我们会经常用到 HashMap, 非常有必要了解源码。 HashMap 基于拉链法和红黑树来实现，关于这两个算法，这里不做解释。 使用方式 1 2 3 4 5</description></item><item><title>时间轮和线程池实现任务执行器</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/%E6%97%B6%E9%97%B4%E8%BD%AE%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C%E5%99%A8/</link><pubDate>Sun, 24 Mar 2024 08:00:00 +0800</pubDate><author>线偶</author><guid>https://ooooo-youwillsee.github.io/ooooo-notes/%E6%97%B6%E9%97%B4%E8%BD%AE%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C%E5%99%A8/</guid><description>java 的线程池可以充当一个任务执行器的，但是有时候不符合我们的要求，所以需要自定义开发。 满足1：可以根据任务数量来动态调整核心线程数和最大线程数</description></item></channel></rss>