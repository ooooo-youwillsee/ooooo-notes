<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>所有文章 - 线偶的IT笔记</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/posts/</link><description>所有文章 | 线偶的IT笔记</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>297872913@qq.com (线偶)</managingEditor><webMaster>297872913@qq.com (线偶)</webMaster><lastBuildDate>Mon, 20 May 2024 08:00:00 +0800</lastBuildDate><atom:link href="https://ooooo-youwillsee.github.io/ooooo-notes/posts/" rel="self" type="application/rss+xml"/><item><title>spring security 原理</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/spring-security-%E5%8E%9F%E7%90%86/</link><pubDate>Mon, 20 May 2024 08:00:00 +0800</pubDate><author>线偶</author><guid>https://ooooo-youwillsee.github.io/ooooo-notes/spring-security-%E5%8E%9F%E7%90%86/</guid><description>spring security 的代码比较难，之前我在 ProcessOn 上做了源码导读，所以这里只说关键点。 理解关键点 认证的逻辑有多个 filter 来完成，常用的 filter 如 UsernamePasswor</description></item><item><title>spring websocket 原理</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/spring-websocket-%E5%8E%9F%E7%90%86/</link><pubDate>Sat, 18 May 2024 08:00:00 +0800</pubDate><author>线偶</author><guid>https://ooooo-youwillsee.github.io/ooooo-notes/spring-websocket-%E5%8E%9F%E7%90%86/</guid><description>使用示例 例子来自于官网 1 2 3 4 5 6 7 8 9 10 11 12 13 14 @Configuration @EnableWebSocket public class WebSocketConfig implements WebSocketConfigurer { @Override public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) { registry.addHandler(myHandler(), &amp;#34;/myHandler&amp;#34;); } @Bean public WebSocketHandler myHandler() { return new MyHandler(); } } 说明： WebSocketConfigurer 配置 websocket。 WebSocketHandler 处</description></item><item><title>spring 常用扩展点</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/spring-%E5%B8%B8%E7%94%A8%E6%89%A9%E5%B1%95%E7%82%B9/</link><pubDate>Fri, 17 May 2024 08:00:00 +0800</pubDate><author>线偶</author><guid>https://ooooo-youwillsee.github.io/ooooo-notes/spring-%E5%B8%B8%E7%94%A8%E6%89%A9%E5%B1%95%E7%82%B9/</guid><description>在 spring 中，最常用的两种扩展就是 BeanFactoryPostProcessor 和 BeanPostProcessor, 当然还有其他的扩展，比如 ApplicationListener, SpringApplicationRunListener 等等。 BeanFactoryPostProcessor 源码位置: org.springframework.beans.factory.config.BeanFactoryPostProcessor 1 2 3 4 5 6 @FunctionalInterface public interface BeanFactoryPostProcessor { // 可以用 beanFactory 来修改 beanDefinition, 注册 singletonBean void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException; }</description></item><item><title>适配多种 servlet 容器</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/%E9%80%82%E9%85%8D%E5%A4%9A%E7%A7%8D-servlet-%E5%AE%B9%E5%99%A8/</link><pubDate>Thu, 16 May 2024 08:00:00 +0800</pubDate><author>线偶</author><guid>https://ooooo-youwillsee.github.io/ooooo-notes/%E9%80%82%E9%85%8D%E5%A4%9A%E7%A7%8D-servlet-%E5%AE%B9%E5%99%A8/</guid><description>自动配置类 源码位置: org.springframework.boot.autoconfigure.web.servlet.ServletWebServerFactoryAutoConfiguration 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // 导入 tomcat，jetty，undertow 的配置 @Import({ ServletWebServerFactoryAutoConfiguration.BeanPostProcessorsRegistrar.class, ServletWebServerFactoryConfiguration.EmbeddedTomcat.class, ServletWebServerFactoryConfiguration.EmbeddedJetty.class, ServletWebServerFactoryConfiguration.EmbeddedUndertow.class }) public class ServletWebServerFactoryAutoConfiguration { @Bean public ServletWebServerFactoryCustomizer servletWebServerFactoryCustomizer(ServerProperties</description></item><item><title>spring boot 启动流程</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/spring-boot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</link><pubDate>Wed, 15 May 2024 08:00:00 +0800</pubDate><author>线偶</author><guid>https://ooooo-youwillsee.github.io/ooooo-notes/spring-boot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</guid><description>spring boot 启动流程必须懂。 启动类示例: 1 2 3 4 5 6 7 8 @SpringBootApplication public class HiApplication { public static void main(String[] args) { // 先执行 SpringApplication 的构造方法，然后执行 run 方法 SpringApplication.run(HiApplication.class, args); } } SpringApplication#run 源码位置: org.springframework.boot.SpringApplication#SpringApplication 1 2 3 4 5 6</description></item><item><title>spring mvc 请求流程</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/spring-mvc-%E8%AF%B7%E6%B1%82%E6%B5%81%E7%A8%8B/</link><pubDate>Tue, 14 May 2024 08:00:00 +0800</pubDate><author>线偶</author><guid>https://ooooo-youwillsee.github.io/ooooo-notes/spring-mvc-%E8%AF%B7%E6%B1%82%E6%B5%81%E7%A8%8B/</guid><description>spring mvc 原理真的必须懂。 DispatcherServlet 源码位置: org.springframework.web.servlet.DispatcherServlet#doDispatch 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 protected void doDispatch(HttpServletRequest</description></item><item><title>spring cache 原理</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/spring-cache-%E5%8E%9F%E7%90%86/</link><pubDate>Mon, 13 May 2024 08:00:00 +0800</pubDate><author>线偶</author><guid>https://ooooo-youwillsee.github.io/ooooo-notes/spring-cache-%E5%8E%9F%E7%90%86/</guid><description>spring cache 是最常见的功能之一，有必要了解其原理。 CacheAutoConfiguration 自动配置类 源码位置: org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // 导入 CacheConfigurationImportSelector 配置类 @Import({ CacheConfigurationImportSelector.class,</description></item><item><title>从零学 rust</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/%E4%BB%8E%E9%9B%B6%E5%AD%A6-rust/</link><pubDate>Sun, 12 May 2024 08:00:00 +0800</pubDate><author>线偶</author><guid>https://ooooo-youwillsee.github.io/ooooo-notes/%E4%BB%8E%E9%9B%B6%E5%AD%A6-rust/</guid><description>为什么学 现在 rust 特别火，我觉得有必须学一学，虽然这门语言上手难，一旦学会了写代码的体验非常好。 怎么学 推荐一些资料 Rust程序设计（第2版） Ru</description></item><item><title>常见的限流算法</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/%E5%B8%B8%E8%A7%81%E7%9A%84%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95/</link><pubDate>Fri, 12 Apr 2024 08:00:00 +0800</pubDate><author>线偶</author><guid>https://ooooo-youwillsee.github.io/ooooo-notes/%E5%B8%B8%E8%A7%81%E7%9A%84%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95/</guid><description>固定窗口算法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 type FixedWindowRateLimiter struct { // 固定窗口大小, 单位ms windowInterval time.Duration // 限制 limit int // 窗口开始时间 prevTime time.Time // 当前限制 curLimit int } func (s *FixedWindowRateLimiter) acquire()</description></item><item><title>简单实现 gossip 协议</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0-gossip-%E5%8D%8F%E8%AE%AE/</link><pubDate>Fri, 12 Apr 2024 08:00:00 +0800</pubDate><author>线偶</author><guid>https://ooooo-youwillsee.github.io/ooooo-notes/%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0-gossip-%E5%8D%8F%E8%AE%AE/</guid><description>gossip 协议是为实现最终一致性提出的。 实现思路 每个节点都有基本属性，如 id, addr, port。 每个节点都有成员列表 members，存储一部分数据 data。 通</description></item></channel></rss>