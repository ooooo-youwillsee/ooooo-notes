<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>所有文章 - 线偶的IT笔记</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/posts/</link><description>所有文章 | 线偶的IT笔记</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>297872913@qq.com (线偶)</managingEditor><webMaster>297872913@qq.com (线偶)</webMaster><lastBuildDate>Mon, 08 Apr 2024 08:00:00 +0800</lastBuildDate><atom:link href="https://ooooo-youwillsee.github.io/ooooo-notes/posts/" rel="self" type="application/rss+xml"/><item><title>01 分布式锁 RedissonLock</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/01-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81-redissonlock/</link><pubDate>Mon, 08 Apr 2024 08:00:00 +0800</pubDate><author>线偶</author><guid>https://ooooo-youwillsee.github.io/ooooo-notes/01-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81-redissonlock/</guid><description><![CDATA[redisson 基于 org.redisson:redisson-spring-data-27:3.27.2 版本 在 java 中，操作 redis 一般都会选择 redisson 框架, 我们需要了解常用功能的实现原理。 使用方式 1 2 3 4 5 6 7 8 9 10 11 @Test void testDistributedLock() { RLock lock = redissonClient.getLock(&#34;lock&#34;); try { lock.lock(); ThreadUtil.sleep(30, TimeUnit.SECONDS); System.out.println(&#34;xxx&#34;); } finally]]></description></item><item><title>05 TreeMap</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/05-treemap/</link><pubDate>Wed, 03 Apr 2024 08:00:00 +0800</pubDate><author>线偶</author><guid>https://ooooo-youwillsee.github.io/ooooo-notes/05-treemap/</guid><description>jdk 基于 8 版本 在平时的开发中，我们很少会用到 TreeMap, 但是还是需要了解源码。 TreeMap 基于红黑树来实现按照 key 排序，关于这个算法，这里不做解释。 使用方式 1 2 3 4</description></item><item><title>04 LinkedHashMap</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/04-linkedhashmap/</link><pubDate>Tue, 02 Apr 2024 08:00:00 +0800</pubDate><author>线偶</author><guid>https://ooooo-youwillsee.github.io/ooooo-notes/04-linkedhashmap/</guid><description>jdk 基于 8 版本 在平时的开发中，我们会经常用到 LinkedHashMap, 非常有必要了解源码。 LinkedHashMap 基于 HashMap 来实现, 内部借助双向链表来维持访问顺序，可以用来实现 LRU 算法。 使用方式</description></item><item><title>03 HashMap</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/03-hashmap/</link><pubDate>Mon, 01 Apr 2024 08:00:00 +0800</pubDate><author>线偶</author><guid>https://ooooo-youwillsee.github.io/ooooo-notes/03-hashmap/</guid><description>jdk 基于 8 版本 在平时的开发中，我们会经常用到 HashMap, 非常有必要了解源码。 HashMap 基于拉链法和红黑树来实现，关于这两个算法，这里不做解释。 使用方式 1 2 3 4 5</description></item><item><title>使用时间轮和线程池实现一个任务执行器</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/%E4%BD%BF%E7%94%A8%E6%97%B6%E9%97%B4%E8%BD%AE%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C%E5%99%A8/</link><pubDate>Sun, 24 Mar 2024 08:00:00 +0800</pubDate><author>线偶</author><guid>https://ooooo-youwillsee.github.io/ooooo-notes/%E4%BD%BF%E7%94%A8%E6%97%B6%E9%97%B4%E8%BD%AE%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C%E5%99%A8/</guid><description>java 的线程池可以充当一个任务执行器的，但是有时候不符合我们的要求，所以需要自定义开发。 满足1：可以根据任务数量来动态调整核心线程数和最大线程数</description></item><item><title>实现一个软引用缓存</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%BD%AF%E5%BC%95%E7%94%A8%E7%BC%93%E5%AD%98/</link><pubDate>Wed, 20 Mar 2024 08:00:00 +0800</pubDate><author>线偶</author><guid>https://ooooo-youwillsee.github.io/ooooo-notes/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%BD%AF%E5%BC%95%E7%94%A8%E7%BC%93%E5%AD%98/</guid><description>在 java 中有四种引用类型，分为强引用，软引用，弱引用，虚引用，这里介绍如何使用软引用来实现一个缓存。 实现代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18</description></item><item><title>01 ArrayList</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/01-arraylist/</link><pubDate>Mon, 18 Mar 2024 08:00:00 +0800</pubDate><author>线偶</author><guid>https://ooooo-youwillsee.github.io/ooooo-notes/01-arraylist/</guid><description><![CDATA[jdk 基于 8 版本 在平时的开发中，我们会经常用到 ArrayList, 非常有必要了解源码。 使用方式 1 2 3 4 5 6 7 8 9 10 11 12 13 public class ArrayListTest { @Test void test() { List&lt;String&gt; ids = new ArrayList&lt;&gt;(); assertThat(ids.add(&#34;1&#34;)).isEqualTo(true); assertThat(ids.add(&#34;2&#34;)).isEqualTo(true); assertThat(ids.add(&#34;3&#34;)).isEqualTo(true); assertThat(ids.remove(&#34;2&#34;)).isEqualTo(true); assertThat(ids.set(0, &#34;4&#34;)).isEqualTo(&#34;1&#34;); assertThat(ids.get(0)).isEqualTo(&#34;4&#34;); }]]></description></item><item><title>02 LinkedList</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/02-linkedlist/</link><pubDate>Mon, 18 Mar 2024 08:00:00 +0800</pubDate><author>线偶</author><guid>https://ooooo-youwillsee.github.io/ooooo-notes/02-linkedlist/</guid><description><![CDATA[jdk 基于 8 版本 在平时的开发中，我们会经常用到 LinkedList, 非常有必要了解源码。 使用方式 1 2 3 4 5 6 7 8 9 10 11 12 13 public class LinkedListTest { @Test void test() { List&lt;String&gt; ids = new LinkedList&lt;&gt;(); assertThat(ids.add(&#34;1&#34;)).isEqualTo(true); assertThat(ids.add(&#34;2&#34;)).isEqualTo(true); assertThat(ids.add(&#34;3&#34;)).isEqualTo(true); assertThat(ids.remove(&#34;2&#34;)).isEqualTo(true); assertThat(ids.set(0, &#34;4&#34;)).isEqualTo(&#34;1&#34;); assertThat(ids.get(0)).isEqualTo(&#34;4&#34;); }]]></description></item><item><title>英语日常对话</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/%E8%8B%B1%E8%AF%AD%E6%97%A5%E5%B8%B8%E5%AF%B9%E8%AF%9D/</link><pubDate>Wed, 06 Mar 2024 08:00:00 +0800</pubDate><author>线偶</author><guid>https://ooooo-youwillsee.github.io/ooooo-notes/%E8%8B%B1%E8%AF%AD%E6%97%A5%E5%B8%B8%E5%AF%B9%E8%AF%9D/</guid><description>今天好多人There are many people on the subway 地铁要等好久It&amp;rsquo;s a long wait for the subway. 中午不知道吃啥I don&amp;rsquo;t know what to eat for lunch.</description></item><item><title>事务传播类型</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E7%B1%BB%E5%9E%8B/</link><pubDate>Fri, 23 Feb 2024 08:00:00 +0800</pubDate><author>线偶</author><guid>https://ooooo-youwillsee.github.io/ooooo-notes/%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E7%B1%BB%E5%9E%8B/</guid><description>只要涉及到数据库操作，必定就会使用 @Transactional 注解，其中有一个属性就是 propagation(传播类型)，掌握它的用法很重要。演示代码见末尾。 演示事务</description></item></channel></rss>