<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>All Posts - 线偶的IT笔记</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/posts/</link><description>All Posts | 线偶的IT笔记</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>297872913@qq.com (ooooo-youwillsee)</managingEditor><webMaster>297872913@qq.com (ooooo-youwillsee)</webMaster><lastBuildDate>Sat, 18 Nov 2023 08:00:00 +0800</lastBuildDate><atom:link href="https://ooooo-youwillsee.github.io/ooooo-notes/posts/" rel="self" type="application/rss+xml"/><item><title>spring boot 适配 servlet 规范</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/spring-boot-%E9%80%82%E9%85%8D-servlet-%E8%A7%84%E8%8C%83/</link><pubDate>Sat, 18 Nov 2023 08:00:00 +0800</pubDate><author>ooooo-youwillsee</author><guid>https://ooooo-youwillsee.github.io/ooooo-notes/spring-boot-%E9%80%82%E9%85%8D-servlet-%E8%A7%84%E8%8C%83/</guid><description>在 spring boot 中，只需要创建一个 bean 实现 filter 接口，spring boot 就会把这个 filter 加入到 servlet 容器中。 在实际使用中，常用的接口就是 OncePerRequestFilter 和 OrderedFilter, 所以来看看 spring boot 是如何适配 servlet</description></item><item><title>mybatis-plus 更新字段为 null 的坑</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/mybatis-plus-%E6%9B%B4%E6%96%B0%E5%AD%97%E6%AE%B5%E4%B8%BA-null-%E7%9A%84%E5%9D%91/</link><pubDate>Tue, 07 Nov 2023 08:00:00 +0800</pubDate><author>ooooo-youwillsee</author><guid>https://ooooo-youwillsee.github.io/ooooo-notes/mybatis-plus-%E6%9B%B4%E6%96%B0%E5%AD%97%E6%AE%B5%E4%B8%BA-null-%E7%9A%84%E5%9D%91/</guid><description>字段更新为null的代码 1 2 3 4 5 6 7 8 9 // 实体类字段设置 @TableField(value = &amp;#34;LOCK_EXP_TIME_&amp;#34;, updateStrategy = FieldStrategy.IGNORED) private Date lockExpirationTime; // mapper操作 JobEntity jobEntity = new JobEntity(); jobEntity.setId(1); jobEntity.setLockExpirationTime(null); JobEntityMapper.updateById(jobEntity); 问题 上面的操作可能会抛出下面的</description></item><item><title>源码分析 rocketmq producer 发送消息</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-rocketmq-producer-%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF/</link><pubDate>Fri, 20 Oct 2023 08:00:00 +0800</pubDate><author>ooooo-youwillsee</author><guid>https://ooooo-youwillsee.github.io/ooooo-notes/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-rocketmq-producer-%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF/</guid><description>rocketmq 基于 5.1.4 版本 在 rocketmq 中，消息分为多个类型，比如普通消息、批量消息、延迟消息、事务消息等，这一节主要介绍普通消息的逻辑，后面的章节会继续介绍其他消</description></item><item><title>源码分析 rocketmq broker 注册 namesvr</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-rocketmq-broker-%E6%B3%A8%E5%86%8C-namesvr/</link><pubDate>Thu, 19 Oct 2023 08:00:00 +0800</pubDate><author>ooooo-youwillsee</author><guid>https://ooooo-youwillsee.github.io/ooooo-notes/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-rocketmq-broker-%E6%B3%A8%E5%86%8C-namesvr/</guid><description>rocketmq 基于 5.1.4 版本 broker 发起注册请求 源码位置: org.apache.rocketmq.broker.BrokerController#start 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // 启动定时任务，发起 broker 注册 public void start() throws Exception {</description></item><item><title>源码分析 activiti 定时任务</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-activiti-%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</link><pubDate>Tue, 17 Oct 2023 08:00:00 +0800</pubDate><author>ooooo-youwillsee</author><guid>https://ooooo-youwillsee.github.io/ooooo-notes/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-activiti-%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</guid><description><![CDATA[activiti 基于 8.0.0 版本 在这一节，详细介绍 BoundaryEvent, 这是工作流框架中很重要的节点，同时涉及到定时任务。 先来看看 BoundaryEvent 的 xml 定义 1 2 3 4 5 6 7 8 9 10 11 12 13 &lt;userTask id=&#34;firstTask&#34; name=&#34;First Task&#34; /&gt; &lt;!-- 在]]></description></item><item><title>源码分析 activiti DbSqlSession</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-activiti-dbsqlsession/</link><pubDate>Mon, 16 Oct 2023 08:00:00 +0800</pubDate><author>ooooo-youwillsee</author><guid>https://ooooo-youwillsee.github.io/ooooo-notes/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-activiti-dbsqlsession/</guid><description>activiti 基于 8.0.0 版本 工作流操作数据库，并不是直接执行 SQL 语句来完成的，而是通过操作缓存对象来实现的。 Entity 类 源码位置: org.activiti.engine.impl.persistence.entity.Entity 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17</description></item><item><title>源码分析 activiti CommandExecutor 执行命令</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-activiti-commandexecutor-%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4/</link><pubDate>Sun, 15 Oct 2023 08:00:00 +0800</pubDate><author>ooooo-youwillsee</author><guid>https://ooooo-youwillsee.github.io/ooooo-notes/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-activiti-commandexecutor-%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4/</guid><description>activiti 基于 8.0.0 版本 从之前的分析可以发现，工作流的每个操作都是一个 Command, 所以有必要看看内部的实现机制。 Command 类 源码位置: org.activiti.engine.impl.interceptor.Command 1 2 3 4 5 6 // 接口非常简单，执行过</description></item><item><title>搭建 rocketmq 源码调试环境</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/%E6%90%AD%E5%BB%BA-rocketmq-%E6%BA%90%E7%A0%81%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83/</link><pubDate>Sat, 14 Oct 2023 08:00:00 +0800</pubDate><author>ooooo-youwillsee</author><guid>https://ooooo-youwillsee.github.io/ooooo-notes/%E6%90%AD%E5%BB%BA-rocketmq-%E6%BA%90%E7%A0%81%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83/</guid><description>rocketmq 基于 5.1.4 版本 启动 namesrv 在 org.apache.rocketmq.namesrv.NamesrvStartup 中，配置环境变量 ROCKETMQ_HOME，如下图。 启动 namesrv 启动 broker 在 org.apache.rocketmq.broker.BrokerController 中，配置环境变量 ROCKETMQ_HOME 和启动参数，如下图。 1 2 3 # -n 指</description></item><item><title>源码分析 activiti 常用的 ActivityBehavior</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-activiti-%E5%B8%B8%E7%94%A8%E7%9A%84-activitybehavior/</link><pubDate>Sat, 14 Oct 2023 08:00:00 +0800</pubDate><author>ooooo-youwillsee</author><guid>https://ooooo-youwillsee.github.io/ooooo-notes/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-activiti-%E5%B8%B8%E7%94%A8%E7%9A%84-activitybehavior/</guid><description>activiti 基于 8.0.0 版本 通过在【agenda流转节点】章节，我们知道了每一个节点的行为由对应的 behavior 来决定，所以有必要看看常用的 behavior 实现。 StartEvent 对应的 behavior 类: NoneStartEventActivityBehavior 可以</description></item><item><title>源码分析 activiti Agenda 流转节点</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-activiti-agenda-%E6%B5%81%E8%BD%AC%E8%8A%82%E7%82%B9/</link><pubDate>Fri, 13 Oct 2023 08:00:00 +0800</pubDate><author>ooooo-youwillsee</author><guid>https://ooooo-youwillsee.github.io/ooooo-notes/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-activiti-agenda-%E6%B5%81%E8%BD%AC%E8%8A%82%E7%82%B9/</guid><description>activiti 基于 8.0.0 版本 Agenda 类是工作流框架中非常重要的类，它控制着节点怎么流转。这部分的代码比较复杂，建议多调试几遍。下面的代码实际上是一个闭环，从开始的</description></item></channel></rss>