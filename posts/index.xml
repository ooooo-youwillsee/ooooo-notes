<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>所有文章 - 线偶的IT笔记</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/posts/</link><description>所有文章 | 线偶的IT笔记</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>297872913@qq.com (线偶)</managingEditor><webMaster>297872913@qq.com (线偶)</webMaster><lastBuildDate>Wed, 26 Jun 2024 08:00:00 +0800</lastBuildDate><atom:link href="https://ooooo-youwillsee.github.io/ooooo-notes/posts/" rel="self" type="application/rss+xml"/><item><title>12 LinkedBlockingQueue</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/12-linkedblockingqueue/</link><pubDate>Wed, 26 Jun 2024 08:00:00 +0800</pubDate><author>线偶</author><guid>https://ooooo-youwillsee.github.io/ooooo-notes/12-linkedblockingqueue/</guid><description><![CDATA[jdk 基于 8 版本 在平时的开发中，我们经常会用到 LinkedBlockingQueue, 它是基于链表来实现的，是并发安全的。 使用方式 1 2 3 4 5 6 7 8 9 public class LinkedBlockingQueueTest { @Test void test() { BlockingQueue&lt;String&gt; queue = new LinkedBlockingQueue&lt;&gt;(10); queue.offer(&#34;1&#34;); assertThat(queue.poll()).isEqualTo(&#34;1&#34;); } }]]></description></item><item><title>11 ArrayBlockingQueue</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/11-arrayblockingqueue/</link><pubDate>Tue, 25 Jun 2024 08:00:00 +0800</pubDate><author>线偶</author><guid>https://ooooo-youwillsee.github.io/ooooo-notes/11-arrayblockingqueue/</guid><description><![CDATA[jdk 基于 8 版本 在平时的开发中，我们可能会用到 ArrayBlockingQueue, 它是基于循环数组来实现的，是并发安全的。 使用方式 1 2 3 4 5 6 7 8 9 public class ArrayBlockingQueueTest { @Test void test() { BlockingQueue&lt;String&gt; queue = new ArrayBlockingQueue&lt;&gt;(10); queue.offer(&#34;1&#34;); assertThat(queue.poll()).isEqualTo(&#34;1&#34;);]]></description></item><item><title>rust axum 测试类</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/rust-axum-%E6%B5%8B%E8%AF%95%E7%B1%BB/</link><pubDate>Mon, 10 Jun 2024 08:00:00 +0800</pubDate><author>线偶</author><guid>https://ooooo-youwillsee.github.io/ooooo-notes/rust-axum-%E6%B5%8B%E8%AF%95%E7%B1%BB/</guid><description><![CDATA[multipart 测试类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 const BOUNDARY: &amp;str = &#34;BOUNDARY&#34;; #[tokio::test] async fn test_import_proc_def() -&gt; anyhow::Result&lt;()&gt; { let bytes = fs::read(&#34;./examples/test01.xml&#34;).await?; let request = Request::builder() .header( CONTENT_TYPE, format!(&#34;multipart/form-data; boundary={}&#34;, BOUNDARY), ) .body::&lt;Body&gt;(generate_multipart_data(&#34;file&#34;, &amp;bytes)?.into()) .unwrap(); let multipart = Multipart::from_request(request, &amp;State(())).await?;]]></description></item><item><title>rust openssl 依赖</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/rust-openssl-%E4%BE%9D%E8%B5%96/</link><pubDate>Sun, 09 Jun 2024 08:00:00 +0800</pubDate><author>线偶</author><guid>https://ooooo-youwillsee.github.io/ooooo-notes/rust-openssl-%E4%BE%9D%E8%B5%96/</guid><description>在 window 上使用 openssl, 会遇到错误 failed to run custom build command for openssl-sys v0.9.102. 解决方法 下载 vcpkg, 打开 powershell 执行 ./bootstrap-vcpkg.bat 执行 ./vcpkg.exe install openssl:x64-windows-static 配置环境变量 OPENSSL_DIR=C:\Users\ooooo\Development\Vcpkg\installed\x64-windows-static 重新启动项目编译 参考 stackoverflow github</description></item><item><title>rust 常用依赖库</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/rust-%E5%B8%B8%E7%94%A8%E4%BE%9D%E8%B5%96%E5%BA%93/</link><pubDate>Sat, 01 Jun 2024 08:00:00 +0800</pubDate><author>线偶</author><guid>https://ooooo-youwillsee.github.io/ooooo-notes/rust-%E5%B8%B8%E7%94%A8%E4%BE%9D%E8%B5%96%E5%BA%93/</guid><description>介绍常用的依赖库，持续更新&amp;hellip; async_trait: 异步支持 once_cell: OnceCell 和 Lazy clap: 命令行支持 axum: http 服务 tokio: 异步运行时 serde: 序列化 serde_json: json 序列化 log: 日志门面 env_logger: 日志实现 anyhow: Result chrono: 日期</description></item><item><title>rust 镜像配置</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/rust-%E9%95%9C%E5%83%8F%E9%85%8D%E7%BD%AE/</link><pubDate>Fri, 24 May 2024 08:00:00 +0800</pubDate><author>线偶</author><guid>https://ooooo-youwillsee.github.io/ooooo-notes/rust-%E9%95%9C%E5%83%8F%E9%85%8D%E7%BD%AE/</guid><description>解决 rust 依赖加载太慢的问题。 配置文件 文件路径：用户名/.cargo/config.toml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26</description></item><item><title>09 ConcurrentHashMap</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/09-concurrenthashmap/</link><pubDate>Thu, 23 May 2024 08:00:00 +0800</pubDate><author>线偶</author><guid>https://ooooo-youwillsee.github.io/ooooo-notes/09-concurrenthashmap/</guid><description><![CDATA[jdk 基于 8 版本 在平时的开发中，我们经常会用到 ConcurrentHashMap, 是并发安全的。 使用方式 1 2 3 4 5 6 7 8 9 10 11 public class ConcurrentHashMapTest { @Test void test() { Map&lt;String, String&gt; map = new ConcurrentHashMap&lt;&gt;(); map.put(&#34;1&#34;, &#34;1&#34;); assertThat(map.get(&#34;1&#34;)).isEqualTo(&#34;1&#34;); map.remove(&#34;1&#34;); assertThat(map.size()).isEqualTo(0); } } put 添加元素]]></description></item><item><title>08 CopyOnWriteArrayList</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/08-copyonwritearraylist/</link><pubDate>Wed, 22 May 2024 08:00:00 +0800</pubDate><author>线偶</author><guid>https://ooooo-youwillsee.github.io/ooooo-notes/08-copyonwritearraylist/</guid><description>jdk 基于 8 版本 在平时的开发中，我们经常会用到 CopyOnWriteArrayList, 利用写时复制的机制来保证并发安全, 适合多读少写的场景。 使用方式 1 2 3 4 5 6 7 8 9 10 11 public class CopyOnWriteArrayListTest { @Test public</description></item><item><title>07 ThreadPoolExecutor</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/07-threadpoolexecutor/</link><pubDate>Tue, 21 May 2024 08:00:00 +0800</pubDate><author>线偶</author><guid>https://ooooo-youwillsee.github.io/ooooo-notes/07-threadpoolexecutor/</guid><description>jdk 基于 8 版本 在平时的开发中，我们经常会用到 ThreadPoolExecutor, 需要了解源码。 使用方式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class ThreadPoolTest { @Test void test() { ThreadPoolExecutor executor = new ThreadPoolExecutor( 2, 10, 60, TimeUnit.SECONDS, new LinkedBlockingQueue&amp;lt;&amp;gt;(), new</description></item><item><title>spring bean 初始化</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/spring-bean-%E5%88%9D%E5%A7%8B%E5%8C%96/</link><pubDate>Tue, 21 May 2024 08:00:00 +0800</pubDate><author>线偶</author><guid>https://ooooo-youwillsee.github.io/ooooo-notes/spring-bean-%E5%88%9D%E5%A7%8B%E5%8C%96/</guid><description>spring bean 初始化过程涉及到很多 spring 的扩展接口，源码必懂。 getBean 源码位置: org.springframework.beans.factory.BeanFactory#getBean 1 2 3 4 5 // BeanFactory 是接口，由 AbstractBeanFactory 类来实现 @Override public Object getBean(String name) throws BeansException { return doGetBean(name, null, null, false); } 源码位置: org.springframework.beans.factory.support.AbstractBeanFactory#doGetBean 1 2</description></item></channel></rss>