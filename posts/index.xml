<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>所有文章 - 线偶的IT笔记</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/posts/</link><description>所有文章 | 线偶的IT笔记</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>297872913@qq.com (线偶)</managingEditor><webMaster>297872913@qq.com (线偶)</webMaster><lastBuildDate>Mon, 18 Mar 2024 08:00:00 +0800</lastBuildDate><atom:link href="https://ooooo-youwillsee.github.io/ooooo-notes/posts/" rel="self" type="application/rss+xml"/><item><title>01 ArrayList</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/01-arraylist/</link><pubDate>Mon, 18 Mar 2024 08:00:00 +0800</pubDate><author>线偶</author><guid>https://ooooo-youwillsee.github.io/ooooo-notes/01-arraylist/</guid><description><![CDATA[jdk 基于 8 版本 在平时的开发中，我们会经常用到 ArrayList, 非常有必要了解源码。 使用方式 1 2 3 4 5 6 7 8 9 10 11 12 13 public class ArrayListTest { @Test void test() { List&lt;String&gt; ids = new ArrayList&lt;&gt;(); assertThat(ids.add(&#34;1&#34;)).isEqualTo(true); assertThat(ids.add(&#34;2&#34;)).isEqualTo(true); assertThat(ids.add(&#34;3&#34;)).isEqualTo(true); assertThat(ids.remove(&#34;2&#34;)).isEqualTo(true); assertThat(ids.set(0, &#34;4&#34;)).isEqualTo(&#34;1&#34;); assertThat(ids.get(0)).isEqualTo(&#34;4&#34;); }]]></description></item><item><title>02 LinkedList</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/02-linkedlist/</link><pubDate>Mon, 18 Mar 2024 08:00:00 +0800</pubDate><author>线偶</author><guid>https://ooooo-youwillsee.github.io/ooooo-notes/02-linkedlist/</guid><description><![CDATA[jdk 基于 8 版本 在平时的开发中，我们会经常用到 LinkedList, 非常有必要了解源码。 使用方式 1 2 3 4 5 6 7 8 9 10 11 12 13 public class LinkedListTest { @Test void test() { List&lt;String&gt; ids = new LinkedList&lt;&gt;(); assertThat(ids.add(&#34;1&#34;)).isEqualTo(true); assertThat(ids.add(&#34;2&#34;)).isEqualTo(true); assertThat(ids.add(&#34;3&#34;)).isEqualTo(true); assertThat(ids.remove(&#34;2&#34;)).isEqualTo(true); assertThat(ids.set(0, &#34;4&#34;)).isEqualTo(&#34;1&#34;); assertThat(ids.get(0)).isEqualTo(&#34;4&#34;); }]]></description></item><item><title>英语日常对话</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/%E8%8B%B1%E8%AF%AD%E6%97%A5%E5%B8%B8%E5%AF%B9%E8%AF%9D/</link><pubDate>Wed, 06 Mar 2024 08:00:00 +0800</pubDate><author>线偶</author><guid>https://ooooo-youwillsee.github.io/ooooo-notes/%E8%8B%B1%E8%AF%AD%E6%97%A5%E5%B8%B8%E5%AF%B9%E8%AF%9D/</guid><description>今天好多人There are many people on the subway 地铁要等好久It&amp;rsquo;s a long wait for the subway. 中午不知道吃啥I don&amp;rsquo;t know what to eat for lunch.</description></item><item><title>事务传播类型</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E7%B1%BB%E5%9E%8B/</link><pubDate>Fri, 23 Feb 2024 08:00:00 +0800</pubDate><author>线偶</author><guid>https://ooooo-youwillsee.github.io/ooooo-notes/%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E7%B1%BB%E5%9E%8B/</guid><description>只要涉及到数据库操作，必定就会使用 @Transactional 注解，其中有一个属性就是 propagation(传播类型)，掌握它的用法很重要。演示代码见末尾。 演示事务</description></item><item><title>缓存一致性问题</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98/</link><pubDate>Sun, 07 Jan 2024 08:00:00 +0800</pubDate><author>线偶</author><guid>https://ooooo-youwillsee.github.io/ooooo-notes/%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98/</guid><description>当我们使用缓存时，必定会遇到缓存一致性问题，也就是在读写请求过程中数据库和缓存中的数据不一致。 下面将分析为什么会造成不一致, 所有的代码参考末</description></item><item><title>异步 servlet 原理</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/%E5%BC%82%E6%AD%A5-servlet-%E5%8E%9F%E7%90%86/</link><pubDate>Sat, 06 Jan 2024 08:00:00 +0800</pubDate><author>线偶</author><guid>https://ooooo-youwillsee.github.io/ooooo-notes/%E5%BC%82%E6%AD%A5-servlet-%E5%8E%9F%E7%90%86/</guid><description>在 servlet 3.0 的规范中，有异步servlet特性，这个可以增大吞吐量。我们有必要看看 spring 是如何适配这个特性的。 实现异步 servlet在 spring mvc 中，实现异步</description></item><item><title>2024年学习计划</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/2024%E5%B9%B4%E8%AE%A1%E5%88%92/</link><pubDate>Mon, 01 Jan 2024 09:00:00 +0800</pubDate><author>线偶</author><guid>https://ooooo-youwillsee.github.io/ooooo-notes/2024%E5%B9%B4%E8%AE%A1%E5%88%92/</guid><description><![CDATA[&#x2b55; 进行中 &#x2705; 已完成 &#x274c; 已废弃 &#x2753; 有必要 &#x2757; 重要性 &#x1f4dd; 记笔记 &#x1f58a;&#xfe0f; 写代码 1. 关于阅读&#x30;&#xfe0f;&#x20e3;&#x31;&#xfe0f;&]]></description></item><item><title>13 集成 k8s</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/13-%E9%9B%86%E6%88%90-k8s/</link><pubDate>Mon, 25 Dec 2023 08:00:00 +0800</pubDate><author>线偶</author><guid>https://ooooo-youwillsee.github.io/ooooo-notes/13-%E9%9B%86%E6%88%90-k8s/</guid><description>dubbo 基于 3.2.6 版本 如果我们将 dubbo 应用部署在 k8s 环境中，我们就可以使用 k8s 作为注册中心。 服务调用流程 provider 使用 KubernetesServiceDiscovery#doRegister 注册服务实例，元数据信息会存放在 pod 对象上. consumer 使</description></item><item><title>12 集成 spring</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/12-%E9%9B%86%E6%88%90-spring/</link><pubDate>Sun, 24 Dec 2023 08:00:00 +0800</pubDate><author>线偶</author><guid>https://ooooo-youwillsee.github.io/ooooo-notes/12-%E9%9B%86%E6%88%90-spring/</guid><description>dubbo 基于 3.2.6 版本 dubbo 集成 spring 的实现方式： 提供 ServiceAnnotationPostProcessor 来扫描 @DubboService 注解，导出服务 提供 ReferenceAnnotationBeanPostProcessor 来扫描 @DubboReference 注解，引用服务 提供 SpringExtensionInjector 来获取 spring 的 bean 提供 DubboInfraBeanRegisterPostProcessor 来注册相关类，加载 spring 配置 Se</description></item><item><title>11 常用过滤器</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/11-%E5%B8%B8%E7%94%A8%E8%BF%87%E6%BB%A4%E5%99%A8/</link><pubDate>Sat, 23 Dec 2023 08:00:00 +0800</pubDate><author>线偶</author><guid>https://ooooo-youwillsee.github.io/ooooo-notes/11-%E5%B8%B8%E7%94%A8%E8%BF%87%E6%BB%A4%E5%99%A8/</guid><description>dubbo 基于 3.2.6 版本 在 dubbo 中，filter 是非常核心的组件之一，很多功能都是依靠 filter 来实现的，下面我来介绍几种常用的 filter 实现。 ConsumerContextFilter (consumer 传递隐式参数)源码位置:</description></item></channel></rss>