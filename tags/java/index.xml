<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>Java - 标签 - 线偶的IT笔记</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/tags/java/</link><description>Java - 标签 | 线偶的IT笔记</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>297872913@qq.com (线偶)</managingEditor><webMaster>297872913@qq.com (线偶)</webMaster><lastBuildDate>Sun, 24 Mar 2024 08:00:00 +0800</lastBuildDate><atom:link href="https://ooooo-youwillsee.github.io/ooooo-notes/tags/java/" rel="self" type="application/rss+xml"/><item><title>使用时间轮和线程池实现一个任务执行器</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/%E4%BD%BF%E7%94%A8%E6%97%B6%E9%97%B4%E8%BD%AE%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C%E5%99%A8/</link><pubDate>Sun, 24 Mar 2024 08:00:00 +0800</pubDate><author>线偶</author><guid>https://ooooo-youwillsee.github.io/ooooo-notes/%E4%BD%BF%E7%94%A8%E6%97%B6%E9%97%B4%E8%BD%AE%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C%E5%99%A8/</guid><description>java 的线程池可以充当一个任务执行器的，但是有时候不符合我们的要求，所以需要自定义开发。 满足1：可以根据任务数量来动态调整核心线程数和最大线程数</description></item><item><title>实现一个软引用缓存</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%BD%AF%E5%BC%95%E7%94%A8%E7%BC%93%E5%AD%98/</link><pubDate>Wed, 20 Mar 2024 08:00:00 +0800</pubDate><author>线偶</author><guid>https://ooooo-youwillsee.github.io/ooooo-notes/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%BD%AF%E5%BC%95%E7%94%A8%E7%BC%93%E5%AD%98/</guid><description>在 java 中有四种引用类型，分为强引用，软引用，弱引用，虚引用，这里介绍如何使用软引用来实现一个缓存。 实现代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18</description></item><item><title>01 ArrayList</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/01-arraylist/</link><pubDate>Mon, 18 Mar 2024 08:00:00 +0800</pubDate><author>线偶</author><guid>https://ooooo-youwillsee.github.io/ooooo-notes/01-arraylist/</guid><description><![CDATA[jdk 基于 8 版本 在平时的开发中，我们会经常用到 ArrayList, 非常有必要了解源码。 使用方式 1 2 3 4 5 6 7 8 9 10 11 12 13 public class ArrayListTest { @Test void test() { List&lt;String&gt; ids = new ArrayList&lt;&gt;(); assertThat(ids.add(&#34;1&#34;)).isEqualTo(true); assertThat(ids.add(&#34;2&#34;)).isEqualTo(true); assertThat(ids.add(&#34;3&#34;)).isEqualTo(true); assertThat(ids.remove(&#34;2&#34;)).isEqualTo(true); assertThat(ids.set(0, &#34;4&#34;)).isEqualTo(&#34;1&#34;); assertThat(ids.get(0)).isEqualTo(&#34;4&#34;); }]]></description></item><item><title>02 LinkedList</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/02-linkedlist/</link><pubDate>Mon, 18 Mar 2024 08:00:00 +0800</pubDate><author>线偶</author><guid>https://ooooo-youwillsee.github.io/ooooo-notes/02-linkedlist/</guid><description><![CDATA[jdk 基于 8 版本 在平时的开发中，我们会经常用到 LinkedList, 非常有必要了解源码。 使用方式 1 2 3 4 5 6 7 8 9 10 11 12 13 public class LinkedListTest { @Test void test() { List&lt;String&gt; ids = new LinkedList&lt;&gt;(); assertThat(ids.add(&#34;1&#34;)).isEqualTo(true); assertThat(ids.add(&#34;2&#34;)).isEqualTo(true); assertThat(ids.add(&#34;3&#34;)).isEqualTo(true); assertThat(ids.remove(&#34;2&#34;)).isEqualTo(true); assertThat(ids.set(0, &#34;4&#34;)).isEqualTo(&#34;1&#34;); assertThat(ids.get(0)).isEqualTo(&#34;4&#34;); }]]></description></item><item><title>h2 数据库使用</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/h2-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BD%BF%E7%94%A8/</link><pubDate>Wed, 15 Mar 2023 08:00:00 +0800</pubDate><author>线偶</author><guid>https://ooooo-youwillsee.github.io/ooooo-notes/h2-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BD%BF%E7%94%A8/</guid><description><![CDATA[怎么使用 h2 数据库。 1. 引入依赖 1 2 3 4 dependencies { api(&#39;p6spy:p6spy&#39;) api(&#39;com.h2database:h2&#39;) } 2. 以内存的方式使用 1 2 3 4 5 # spring boot 配置 spring: datasource: driverClassName: com.p6spy.engine.spy.P6SpyDriver url: jdbc:p6spy:h2:mem:test;DB_CLOSE_DELAY=1000 3. 以进程的方式使用 1 2 3 4 5 6 7 8 # 启动 h2 数]]></description></item><item><title>openjdk build</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/openjdk-build/</link><pubDate>Wed, 01 Feb 2023 08:00:00 +0800</pubDate><author>线偶</author><guid>https://ooooo-youwillsee.github.io/ooooo-notes/openjdk-build/</guid><description><![CDATA[相关命令 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 sudo apt install build-essential manpages-dev software-properties-common sudo add-apt-repository ppa:ubuntu-toolchain-r/test sudo apt update &amp;&amp; sudo apt install gcc-11 g++-11 1. sudo apt update &amp;&amp; sudo apt upgrade gcc libfontconfig1-dev systemtap-sdt-dev libx11-dev sudo apt-get install libx11-dev libxext-dev libxrender-dev libxrandr-dev libxtst-dev libxt-dev sudo apt-get install libcups2-dev sudo apt-get install libasound2-dev]]></description></item><item><title>在 java 中使用 CAS 来实现队列</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/%E5%9C%A8-java-%E4%B8%AD%E4%BD%BF%E7%94%A8-cas-%E6%9D%A5%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</link><pubDate>Wed, 16 Nov 2022 08:00:00 +0800</pubDate><author>线偶</author><guid>https://ooooo-youwillsee.github.io/ooooo-notes/%E5%9C%A8-java-%E4%B8%AD%E4%BD%BF%E7%94%A8-cas-%E6%9D%A5%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</guid><description>1. 实现队列代码： 使用 head 和 tail 来实现单链表 单链表涉及到两个节点，每次都要判断中间状态 这里使用的是 AtomicReference 来实现的，也可以使用 unsafe 来实现，有兴趣的可以尝试</description></item><item><title>在 java 中使用 Lock 来实现 Semaphore</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/%E5%9C%A8-java-%E4%B8%AD%E4%BD%BF%E7%94%A8-lock-%E6%9D%A5%E5%AE%9E%E7%8E%B0-semaphore/</link><pubDate>Mon, 14 Nov 2022 08:00:00 +0800</pubDate><author>线偶</author><guid>https://ooooo-youwillsee.github.io/ooooo-notes/%E5%9C%A8-java-%E4%B8%AD%E4%BD%BF%E7%94%A8-lock-%E6%9D%A5%E5%AE%9E%E7%8E%B0-semaphore/</guid><description>1. 使用 Lock 来实现 Semaphore代码： Semaphore 的功能就是允许同时有几个线程操作 acquire 方法，permit 会减一，如果为 0，则线程需要等待 release 方法，perm</description></item><item><title>在 java 中使用 CAS 来实现栈2</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/%E5%9C%A8-java-%E4%B8%AD%E4%BD%BF%E7%94%A8-cas-%E6%9D%A5%E5%AE%9E%E7%8E%B0%E6%A0%882/</link><pubDate>Sun, 13 Nov 2022 08:00:00 +0800</pubDate><author>线偶</author><guid>https://ooooo-youwillsee.github.io/ooooo-notes/%E5%9C%A8-java-%E4%B8%AD%E4%BD%BF%E7%94%A8-cas-%E6%9D%A5%E5%AE%9E%E7%8E%B0%E6%A0%882/</guid><description>1. 使用数组来实现栈代码： 用数组来实现 用 CTL 来控制 测试类，参考 ConcurrentStackUsingArrayTest 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 public class ConcurrentStackUsingArray&amp;lt;E&amp;gt;</description></item><item><title>在 java 中如何进行多线程测试</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/%E5%9C%A8-java-%E4%B8%AD%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%B5%8B%E8%AF%95/</link><pubDate>Sat, 12 Nov 2022 09:00:00 +0800</pubDate><author>线偶</author><guid>https://ooooo-youwillsee.github.io/ooooo-notes/%E5%9C%A8-java-%E4%B8%AD%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%B5%8B%E8%AF%95/</guid><description>1. java 多线程测试在任何语言中，多线程测试都是比较困难的，在这里我介绍下 java 的多线程测试 jcstress. jcstress 是 OpenJDK 提供的一个测试多线程的框架 主要由多个 Actor 来构成，每个</description></item></channel></rss>