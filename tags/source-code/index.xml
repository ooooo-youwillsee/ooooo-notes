<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>Source Code - 标签 - 线偶的IT笔记</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/tags/source-code/</link><description>Source Code - 标签 | 线偶的IT笔记</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>297872913@qq.com (线偶)</managingEditor><webMaster>297872913@qq.com (线偶)</webMaster><lastBuildDate>Thu, 16 May 2024 08:00:00 +0800</lastBuildDate><atom:link href="https://ooooo-youwillsee.github.io/ooooo-notes/tags/source-code/" rel="self" type="application/rss+xml"/><item><title>适配多种 servlet 容器</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/%E9%80%82%E9%85%8D%E5%A4%9A%E7%A7%8D-servlet-%E5%AE%B9%E5%99%A8/</link><pubDate>Thu, 16 May 2024 08:00:00 +0800</pubDate><author>线偶</author><guid>https://ooooo-youwillsee.github.io/ooooo-notes/%E9%80%82%E9%85%8D%E5%A4%9A%E7%A7%8D-servlet-%E5%AE%B9%E5%99%A8/</guid><description>自动配置类 源码位置: org.springframework.boot.autoconfigure.web.servlet.ServletWebServerFactoryAutoConfiguration 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // 导入 tomcat，jetty，undertow 的配置 @Import({ ServletWebServerFactoryAutoConfiguration.BeanPostProcessorsRegistrar.class, ServletWebServerFactoryConfiguration.EmbeddedTomcat.class, ServletWebServerFactoryConfiguration.EmbeddedJetty.class, ServletWebServerFactoryConfiguration.EmbeddedUndertow.class }) public class ServletWebServerFactoryAutoConfiguration { @Bean public ServletWebServerFactoryCustomizer servletWebServerFactoryCustomizer(ServerProperties</description></item><item><title>spring boot 启动流程</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/spring-boot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</link><pubDate>Wed, 15 May 2024 08:00:00 +0800</pubDate><author>线偶</author><guid>https://ooooo-youwillsee.github.io/ooooo-notes/spring-boot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</guid><description>spring boot 启动流程必须懂。 启动类示例: 1 2 3 4 5 6 7 8 @SpringBootApplication public class HiApplication { public static void main(String[] args) { // 先执行 SpringApplication 的构造方法，然后执行 run 方法 SpringApplication.run(HiApplication.class, args); } } SpringApplication#run 源码位置: org.springframework.boot.SpringApplication#SpringApplication 1 2 3 4 5 6</description></item><item><title>spring mvc 请求流程</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/spring-mvc-%E8%AF%B7%E6%B1%82%E6%B5%81%E7%A8%8B/</link><pubDate>Tue, 14 May 2024 08:00:00 +0800</pubDate><author>线偶</author><guid>https://ooooo-youwillsee.github.io/ooooo-notes/spring-mvc-%E8%AF%B7%E6%B1%82%E6%B5%81%E7%A8%8B/</guid><description>spring mvc 原理真的必须懂。 DispatcherServlet 源码位置: org.springframework.web.servlet.DispatcherServlet#doDispatch 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 protected void doDispatch(HttpServletRequest</description></item><item><title>spring cache 原理</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/spring-cache-%E5%8E%9F%E7%90%86/</link><pubDate>Mon, 13 May 2024 08:00:00 +0800</pubDate><author>线偶</author><guid>https://ooooo-youwillsee.github.io/ooooo-notes/spring-cache-%E5%8E%9F%E7%90%86/</guid><description>spring cache 是最常见的功能之一，有必要了解其原理。 CacheAutoConfiguration 自动配置类 源码位置: org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // 导入 CacheConfigurationImportSelector 配置类 @Import({ CacheConfigurationImportSelector.class,</description></item><item><title>04 RedissonSortedSet</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/04-redissonsortedset/</link><pubDate>Thu, 11 Apr 2024 08:00:00 +0800</pubDate><author>线偶</author><guid>https://ooooo-youwillsee.github.io/ooooo-notes/04-redissonsortedset/</guid><description>redisson 基于 org.redisson:redisson-spring-data-27:3.27.2 版本 在 java 中，操作 redis 一般都会选择 redisson 框架, 我们需要了解常用功能的实现原理, 这次来介绍 RedissonSortedSet。 使用方式 1 2 3 4</description></item><item><title>05 RedissonPriorityQueue</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/05-redissonpriorityqueue/</link><pubDate>Thu, 11 Apr 2024 08:00:00 +0800</pubDate><author>线偶</author><guid>https://ooooo-youwillsee.github.io/ooooo-notes/05-redissonpriorityqueue/</guid><description>redisson 基于 org.redisson:redisson-spring-data-27:3.27.2 版本 在 java 中，操作 redis 一般都会选择 redisson 框架, 我们需要了解常用功能的实现原理, 这次来介绍 RedissonPriorityQueue。 使用方式</description></item><item><title>03 RedissonMultiLock</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/03-redissonmultilock/</link><pubDate>Wed, 10 Apr 2024 08:00:00 +0800</pubDate><author>线偶</author><guid>https://ooooo-youwillsee.github.io/ooooo-notes/03-redissonmultilock/</guid><description>redisson 基于 org.redisson:redisson-spring-data-27:3.27.2 版本 在 java 中，操作 redis 一般都会选择 redisson 框架, 我们需要了解常用功能的实现原理, 这次来介绍 RedissonMultiLock。 使用方式 1 2 3 4</description></item><item><title>02 RedissonSpinLock</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/02-redissonspinlock/</link><pubDate>Tue, 09 Apr 2024 08:00:00 +0800</pubDate><author>线偶</author><guid>https://ooooo-youwillsee.github.io/ooooo-notes/02-redissonspinlock/</guid><description>redisson 基于 org.redisson:redisson-spring-data-27:3.27.2 版本 在 java 中，操作 redis 一般都会选择 redisson 框架, 我们需要了解常用功能的实现原理, 这次来介绍 RedissonSpinLock。 使用方式 1 2 3 4 5</description></item><item><title>01 RedissonLock</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/01-redissonlock/</link><pubDate>Mon, 08 Apr 2024 08:00:00 +0800</pubDate><author>线偶</author><guid>https://ooooo-youwillsee.github.io/ooooo-notes/01-redissonlock/</guid><description>redisson 基于 org.redisson:redisson-spring-data-27:3.27.2 版本 在 java 中，操作 redis 一般都会选择 redisson 框架, 我们需要了解常用功能的实现原理, 这次来介绍 RedissonLock。 使用方式 1 2 3 4 5 6 7 8 9</description></item><item><title>05 TreeMap</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/05-treemap/</link><pubDate>Wed, 03 Apr 2024 08:00:00 +0800</pubDate><author>线偶</author><guid>https://ooooo-youwillsee.github.io/ooooo-notes/05-treemap/</guid><description>jdk 基于 8 版本 在平时的开发中，我们很少会用到 TreeMap, 但是还是需要了解源码。 TreeMap 基于红黑树来实现按照 key 排序，关于这个算法，这里不做解释。 使用方式 1 2 3 4</description></item></channel></rss>