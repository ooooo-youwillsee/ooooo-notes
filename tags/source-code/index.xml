<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>Source Code - 标签 - 线偶的IT笔记</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/tags/source-code/</link><description>Source Code - 标签 | 线偶的IT笔记</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>297872913@qq.com (线偶)</managingEditor><webMaster>297872913@qq.com (线偶)</webMaster><lastBuildDate>Sun, 21 Jul 2024 08:00:00 +0800</lastBuildDate><atom:link href="https://ooooo-youwillsee.github.io/ooooo-notes/tags/source-code/" rel="self" type="application/rss+xml"/><item><title>17 Semaphore</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/17-semaphore/</link><pubDate>Sun, 21 Jul 2024 08:00:00 +0800</pubDate><author>线偶</author><guid>https://ooooo-youwillsee.github.io/ooooo-notes/17-semaphore/</guid><description>jdk 基于 8 版本 在平时的开发中，我们经常会用到 Semaphore, 它是用于线程通信的工具类。 使用场景: 同时操作的线程个数。 使用方式</description></item><item><title>16 CountDownLatch</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/16-countdownlatch/</link><pubDate>Sat, 13 Jul 2024 08:00:00 +0800</pubDate><author>线偶</author><guid>https://ooooo-youwillsee.github.io/ooooo-notes/16-countdownlatch/</guid><description>jdk 基于 8 版本 在平时的开发中，我们经常会用到 CountDownLatch, 它是用于线程通信的工具类。 常用使用场景就是，主线程等待子线程操作完成，然后继续执行。 使用方式 1 2</description></item><item><title>12 LinkedBlockingQueue</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/12-linkedblockingqueue/</link><pubDate>Wed, 26 Jun 2024 08:00:00 +0800</pubDate><author>线偶</author><guid>https://ooooo-youwillsee.github.io/ooooo-notes/12-linkedblockingqueue/</guid><description>jdk 基于 8 版本 在平时的开发中，我们经常会用到 LinkedBlockingQueue, 它是基于链表来实现的，是并发安全的。 与 ArrayBlockingQueue 相比，LinkedBlockingQueue 的性能会更高</description></item><item><title>14 AtomicInteger</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/14-atomicinteger/</link><pubDate>Wed, 26 Jun 2024 08:00:00 +0800</pubDate><author>线偶</author><guid>https://ooooo-youwillsee.github.io/ooooo-notes/14-atomicinteger/</guid><description>jdk 基于 8 版本 在平时的开发中，我们经常会用到 AtomicInteger, 它是原子计数，与之类似的还有很多，比如 AtomicBoolean, AtomicLong, AtomicReferenceFieldUpdater</description></item><item><title>11 ArrayBlockingQueue</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/11-arrayblockingqueue/</link><pubDate>Tue, 25 Jun 2024 08:00:00 +0800</pubDate><author>线偶</author><guid>https://ooooo-youwillsee.github.io/ooooo-notes/11-arrayblockingqueue/</guid><description><![CDATA[jdk 基于 8 版本 在平时的开发中，我们可能会用到 ArrayBlockingQueue, 它是基于循环数组来实现的，是并发安全的。 使用方式 1 2 3 4 5 6 7 8 9 public class ArrayBlockingQueueTest { @Test void test() { BlockingQueue&lt;String&gt; queue = new ArrayBlockingQueue&lt;&gt;(10); queue.offer(&#34;1&#34;); assertThat(queue.poll()).isEqualTo(&#34;1&#34;);]]></description></item><item><title>09 ConcurrentHashMap</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/09-concurrenthashmap/</link><pubDate>Thu, 23 May 2024 08:00:00 +0800</pubDate><author>线偶</author><guid>https://ooooo-youwillsee.github.io/ooooo-notes/09-concurrenthashmap/</guid><description><![CDATA[jdk 基于 8 版本 在平时的开发中，我们经常会用到 ConcurrentHashMap, 是并发安全的。 使用方式 1 2 3 4 5 6 7 8 9 10 11 public class ConcurrentHashMapTest { @Test void test() { Map&lt;String, String&gt; map = new ConcurrentHashMap&lt;&gt;(); map.put(&#34;1&#34;, &#34;1&#34;); assertThat(map.get(&#34;1&#34;)).isEqualTo(&#34;1&#34;); map.remove(&#34;1&#34;); assertThat(map.size()).isEqualTo(0); } } put 添加元素]]></description></item><item><title>08 CopyOnWriteArrayList</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/08-copyonwritearraylist/</link><pubDate>Wed, 22 May 2024 08:00:00 +0800</pubDate><author>线偶</author><guid>https://ooooo-youwillsee.github.io/ooooo-notes/08-copyonwritearraylist/</guid><description>jdk 基于 8 版本 在平时的开发中，我们经常会用到 CopyOnWriteArrayList, 利用写时复制的机制来保证并发安全, 适合多读少写的场景。 使用方式 1 2 3 4 5 6 7 8 9 10 11 public class CopyOnWriteArrayListTest { @Test public</description></item><item><title>07 ThreadPoolExecutor</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/07-threadpoolexecutor/</link><pubDate>Tue, 21 May 2024 08:00:00 +0800</pubDate><author>线偶</author><guid>https://ooooo-youwillsee.github.io/ooooo-notes/07-threadpoolexecutor/</guid><description>jdk 基于 8 版本 在平时的开发中，我们经常会用到 ThreadPoolExecutor, 需要了解源码。 使用方式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class ThreadPoolTest { @Test void test() { ThreadPoolExecutor executor = new ThreadPoolExecutor( 2, 10, 60, TimeUnit.SECONDS, new LinkedBlockingQueue&amp;lt;&amp;gt;(), new</description></item><item><title>spring bean 初始化</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/spring-bean-%E5%88%9D%E5%A7%8B%E5%8C%96/</link><pubDate>Tue, 21 May 2024 08:00:00 +0800</pubDate><author>线偶</author><guid>https://ooooo-youwillsee.github.io/ooooo-notes/spring-bean-%E5%88%9D%E5%A7%8B%E5%8C%96/</guid><description>spring bean 初始化过程涉及到很多 spring 的扩展接口，源码必懂。 getBean 源码位置: org.springframework.beans.factory.BeanFactory#getBean 1 2 3 4 5 // BeanFactory 是接口，由 AbstractBeanFactory 类来实现 @Override public Object getBean(String name) throws BeansException { return doGetBean(name, null, null, false); } 源码位置: org.springframework.beans.factory.support.AbstractBeanFactory#doGetBean 1 2</description></item><item><title>spring security 原理</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/spring-security-%E5%8E%9F%E7%90%86/</link><pubDate>Mon, 20 May 2024 08:00:00 +0800</pubDate><author>线偶</author><guid>https://ooooo-youwillsee.github.io/ooooo-notes/spring-security-%E5%8E%9F%E7%90%86/</guid><description>spring security 的代码比较难，之前我在 ProcessOn 上做了源码导读，所以这里只说关键点。 理解关键点 认证的逻辑有多个 filter 来完成，常用的 filter 如 UsernamePasswor</description></item></channel></rss>