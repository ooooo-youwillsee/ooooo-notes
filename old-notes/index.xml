<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Old-notes on 线偶的IT笔记</title><link>https://ooooo-youwillsee.github.io/old-notes/</link><description>Recent content in Old-notes on 线偶的IT笔记</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>297872913@qq.com (ooooo-youwillsee)</managingEditor><webMaster>297872913@qq.com (ooooo-youwillsee)</webMaster><atom:link href="https://ooooo-youwillsee.github.io/old-notes/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://ooooo-youwillsee.github.io/old-notes/books/redis-development-and-operation-and-maintenance/01/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>297872913@qq.com (ooooo-youwillsee)</author><guid>https://ooooo-youwillsee.github.io/old-notes/books/redis-development-and-operation-and-maintenance/01/</guid><description>1、Redis 特性 1、速度快 Redis 的所有数据都是放在内存中的。 Redis 是 C 语言实现的。 Redis 使用单线程架构，避免多线程环境上下文切换。 2、基于键值对的数据</description></item><item><title/><link>https://ooooo-youwillsee.github.io/old-notes/books/redis-development-and-operation-and-maintenance/02/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>297872913@qq.com (ooooo-youwillsee)</author><guid>https://ooooo-youwillsee.github.io/old-notes/books/redis-development-and-operation-and-maintenance/02/</guid><description>1、预备 1、全局命令 help 1 HELP command 查看所有的key 1 KEYS * 键总数 1 DBSIZE 检查键是否存在 1 EXISTS key 删除键 1 DEL key 键过期 1 EXPIRE key sencond ttl 返回过期时间 1 TTL key &amp;gt;0: 剩余过期时间</description></item><item><title/><link>https://ooooo-youwillsee.github.io/old-notes/books/redis-development-and-operation-and-maintenance/03/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>297872913@qq.com (ooooo-youwillsee)</author><guid>https://ooooo-youwillsee.github.io/old-notes/books/redis-development-and-operation-and-maintenance/03/</guid><description>1、慢查询 1、慢查询配置 slowlog-log-slower-than: 10000 (默认值，单位微秒)，超过 10 毫秒的语句就会被记录下来。 slowlog-max-len: 128（默认值），Redis 内部使用列表来保存慢查询日志</description></item><item><title/><link>https://ooooo-youwillsee.github.io/old-notes/books/redis-development-and-operation-and-maintenance/04/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>297872913@qq.com (ooooo-youwillsee)</author><guid>https://ooooo-youwillsee.github.io/old-notes/books/redis-development-and-operation-and-maintenance/04/</guid><description>1、客户端通信协议 Redis 制定了 RESP（redis序列化协议）实现客户端和服务端的正常交互。 1、发送命令格式 CRLF 为 &amp;lsquo;\r\n&amp;rsquo; 1 2 3 4 5 6 *&amp;lt;参数数量</description></item><item><title/><link>https://ooooo-youwillsee.github.io/old-notes/books/redis-development-and-operation-and-maintenance/05/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>297872913@qq.com (ooooo-youwillsee)</author><guid>https://ooooo-youwillsee.github.io/old-notes/books/redis-development-and-operation-and-maintenance/05/</guid><description>1、RDB 1、触发机制 手动触发，分别有 save 和 bgsave 两个命令。 save： 会阻塞当前 Redis 服务器，直到 RDB 过程完成为止，不建议使用。 bgsave： Redis 进程会 fork</description></item><item><title/><link>https://ooooo-youwillsee.github.io/old-notes/books/redis-development-and-operation-and-maintenance/06/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>297872913@qq.com (ooooo-youwillsee)</author><guid>https://ooooo-youwillsee.github.io/old-notes/books/redis-development-and-operation-and-maintenance/06/</guid><description>1、配置 1、建立复制 建立复制前会删除全部数据。 配置复制的方式有三种； 配置文件中加入 slaveof {masterHost} {masterPort}。 redis 启动命令后加入 slaveof {masterHost} {mas</description></item><item><title/><link>https://ooooo-youwillsee.github.io/old-notes/books/redis-development-and-operation-and-maintenance/readme/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>297872913@qq.com (ooooo-youwillsee)</author><guid>https://ooooo-youwillsee.github.io/old-notes/books/redis-development-and-operation-and-maintenance/readme/</guid><description>Redis 开发与运维 第一章 初识 Redis 第二章 API 的理解和使用 第三章 小功能大用处 第四章 客户端 第五章 持久化 第六章 复制</description></item><item><title/><link>https://ooooo-youwillsee.github.io/old-notes/books/the-art-of-java-concurrent-programming/01/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>297872913@qq.com (ooooo-youwillsee)</author><guid>https://ooooo-youwillsee.github.io/old-notes/books/the-art-of-java-concurrent-programming/01/</guid><description>1、上下文切换 CPU 通过时间片分配算法来循环执行任务，当前任务执行完一个时间片后会切换到下一个任务。但是在切换前会保存上一个任务的状态，以便下次</description></item><item><title/><link>https://ooooo-youwillsee.github.io/old-notes/books/the-art-of-java-concurrent-programming/readme/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>297872913@qq.com (ooooo-youwillsee)</author><guid>https://ooooo-youwillsee.github.io/old-notes/books/the-art-of-java-concurrent-programming/readme/</guid><description>Java 并发编程的艺术 第一章 并发编程的挑战 第二章 Java 并发机制的底层实现原理 第三章 Java 内存模型</description></item><item><title/><link>https://ooooo-youwillsee.github.io/old-notes/geektime/java-con-practice/readme/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>297872913@qq.com (ooooo-youwillsee)</author><guid>https://ooooo-youwillsee.github.io/old-notes/geektime/java-con-practice/readme/</guid><description>Java 并发编程实战</description></item><item><title/><link>https://ooooo-youwillsee.github.io/old-notes/geektime/java-core-36/01/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>297872913@qq.com (ooooo-youwillsee)</author><guid>https://ooooo-youwillsee.github.io/old-notes/geektime/java-core-36/01/</guid><description>1、Java本身有两个显著的特性 JRE 就是 Java 运行环境， JDK 就是 Java 开发工具包 跨平台运行（一次编写，到处运行） 垃圾回收器（程序员不用手动回收内存，但仍</description></item><item><title/><link>https://ooooo-youwillsee.github.io/old-notes/geektime/java-core-36/02/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>297872913@qq.com (ooooo-youwillsee)</author><guid>https://ooooo-youwillsee.github.io/old-notes/geektime/java-core-36/02/</guid><description>1、Exception 和 Error Exception 和 Error 都继承 Throwable 类，只有 Throwable 类的实例才可以抛出。 Exception 是可以预料的意外情况，可以被捕获进行相应的处理。而 Error 是不太可能出现的</description></item><item><title/><link>https://ooooo-youwillsee.github.io/old-notes/geektime/java-core-36/03/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>297872913@qq.com (ooooo-youwillsee)</author><guid>https://ooooo-youwillsee.github.io/old-notes/geektime/java-core-36/03/</guid><description>1、final final 修饰的类，不能被继承。 final 修饰的变量，不能被修改。 final 修饰的方法，不能被重写。 final 不是 immutable，对象的属性还是可以改变的</description></item><item><title/><link>https://ooooo-youwillsee.github.io/old-notes/geektime/java-core-36/04/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>297872913@qq.com (ooooo-youwillsee)</author><guid>https://ooooo-youwillsee.github.io/old-notes/geektime/java-core-36/04/</guid><description>1、kafka概念 ​ Apache Kafka是一款开源的消息引擎系统，也是一个分布式流处理平台；消息引擎系统是一组规范，企业利用这组规范在不同系统之间传</description></item><item><title/><link>https://ooooo-youwillsee.github.io/old-notes/geektime/java-core-36/readme/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>297872913@qq.com (ooooo-youwillsee)</author><guid>https://ooooo-youwillsee.github.io/old-notes/geektime/java-core-36/readme/</guid><description>Java 核心技术 36讲 01、谈谈你对 Java 的理解 02、Exception 和 Error 的区别 03、final、finally、finalize 的区别</description></item><item><title/><link>https://ooooo-youwillsee.github.io/old-notes/geektime/kafka-core-tech/01/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>297872913@qq.com (ooooo-youwillsee)</author><guid>https://ooooo-youwillsee.github.io/old-notes/geektime/kafka-core-tech/01/</guid><description>1、Kafka 是一款消息引擎系统 消息引擎系统是一组规范。企业利用这组规范在不同系统之间传递语义准确的消息，实现松耦合的异步式数据传递。 Kafka 的消</description></item><item><title/><link>https://ooooo-youwillsee.github.io/old-notes/geektime/kafka-core-tech/02/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>297872913@qq.com (ooooo-youwillsee)</author><guid>https://ooooo-youwillsee.github.io/old-notes/geektime/kafka-core-tech/02/</guid><description>1、Kafka 术语 Record（消息） Kafka 处理的主要对象。 Topic（主题） 主题是承载消息的逻辑容器，在实际使用中多用来区分具体的业务。 你可以</description></item><item><title/><link>https://ooooo-youwillsee.github.io/old-notes/geektime/kafka-core-tech/03/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>297872913@qq.com (ooooo-youwillsee)</author><guid>https://ooooo-youwillsee.github.io/old-notes/geektime/kafka-core-tech/03/</guid><description>1、Kafka 是分布式流处理平台 Apache Kafka 是消息引擎系统，也是一个分布式流处理平台。 Kafka 的特性： 提供一套 API 实现生产者和消费者。 降低网络传输和磁盘存储</description></item><item><title/><link>https://ooooo-youwillsee.github.io/old-notes/geektime/kafka-core-tech/04/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>297872913@qq.com (ooooo-youwillsee)</author><guid>https://ooooo-youwillsee.github.io/old-notes/geektime/kafka-core-tech/04/</guid><description>1、Kafka 不同的&amp;quot;发行版&amp;quot; 1、Apache Kafka 只提供最基础的组件，没有任何监控框架或工具。 如果你仅仅需要一个消息引擎系</description></item><item><title/><link>https://ooooo-youwillsee.github.io/old-notes/geektime/kafka-core-tech/05/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>297872913@qq.com (ooooo-youwillsee)</author><guid>https://ooooo-youwillsee.github.io/old-notes/geektime/kafka-core-tech/05/</guid><description>1、Kafka 的版本 [scala-version] - [kafka-version].tar.gz 0.10.0.0 引进 Kafka Stream 0.11.0.0 添加幂等性 Producer 和事务 API，并对 Kafka 消息格式进行重构 总结： 如果只使用 Kafka 的消息引擎功能， 最少 0.10.2.2</description></item><item><title/><link>https://ooooo-youwillsee.github.io/old-notes/geektime/kafka-core-tech/06/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>297872913@qq.com (ooooo-youwillsee)</author><guid>https://ooooo-youwillsee.github.io/old-notes/geektime/kafka-core-tech/06/</guid><description>1、操作系统 三个方面选择： I/O 模型的使用 数据网络传输效率 社区支持度 五种 I/O 模型：阻塞式 I/O、非阻塞式 I/O、I/O 多路复用、信号驱动 I/O 和异步 I</description></item><item><title/><link>https://ooooo-youwillsee.github.io/old-notes/geektime/kafka-core-tech/07/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>297872913@qq.com (ooooo-youwillsee)</author><guid>https://ooooo-youwillsee.github.io/old-notes/geektime/kafka-core-tech/07/</guid><description>1、Broker 端参数 1、broker 存储信息 log.dirs: 日志目录，例如 /home/kafka1,/home/kafka2,/home/kafka3。</description></item><item><title/><link>https://ooooo-youwillsee.github.io/old-notes/geektime/kafka-core-tech/08/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>297872913@qq.com (ooooo-youwillsee)</author><guid>https://ooooo-youwillsee.github.io/old-notes/geektime/kafka-core-tech/08/</guid><description>1、Topic 级别参数 如果同时设置了 Topic 级别参数和全局 Broker 参数，Topic 级别参数会覆盖全局 Broker 参数的值，而每个 Topic 都能设置自己的参数值，这就是所谓</description></item><item><title/><link>https://ooooo-youwillsee.github.io/old-notes/geektime/kafka-core-tech/09/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>297872913@qq.com (ooooo-youwillsee)</author><guid>https://ooooo-youwillsee.github.io/old-notes/geektime/kafka-core-tech/09/</guid><description>1、为什么分区 Kafka 的消息组织方式实际上是三级结构：主题 - 分区 - 消息，主题下的每条消息只会保存在某一个分区中。 Kafka 的三级结构： 分区是为了实现系统的</description></item><item><title/><link>https://ooooo-youwillsee.github.io/old-notes/geektime/kafka-core-tech/10/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>297872913@qq.com (ooooo-youwillsee)</author><guid>https://ooooo-youwillsee.github.io/old-notes/geektime/kafka-core-tech/10/</guid><description>1、消息格式 Kafka 的消息格式目前有两种：V1 和 V2。 不论是哪个版本，Kafka 的消息层次都分为两层：消息集合(message set) 和 消息(messa</description></item><item><title/><link>https://ooooo-youwillsee.github.io/old-notes/geektime/kafka-core-tech/readme/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>297872913@qq.com (ooooo-youwillsee)</author><guid>https://ooooo-youwillsee.github.io/old-notes/geektime/kafka-core-tech/readme/</guid><description>Kafka 核心技术与实战 01、消息引擎系统 02、Kafka 术语</description></item><item><title/><link>https://ooooo-youwillsee.github.io/old-notes/geektime/mysql-45/01/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>297872913@qq.com (ooooo-youwillsee)</author><guid>https://ooooo-youwillsee.github.io/old-notes/geektime/mysql-45/01/</guid><description>1、MySQL 的基本架构 主要分为Server层和存储引擎层。 Server层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖MySQL的大</description></item><item><title/><link>https://ooooo-youwillsee.github.io/old-notes/geektime/mysql-45/02/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>297872913@qq.com (ooooo-youwillsee)</author><guid>https://ooooo-youwillsee.github.io/old-notes/geektime/mysql-45/02/</guid><description>1、更新语句的执行流程 创建表 T: 1 mysql&amp;gt; create table T(ID int primary key, c int); 将 ID = 2 这一行的值加 1 的 SQL 语句: 1 mysql&amp;gt; update T set c=c+1 where ID=2; 查询语句的那一套流程，更新语句也是同样会走</description></item><item><title/><link>https://ooooo-youwillsee.github.io/old-notes/geektime/mysql-45/03/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>297872913@qq.com (ooooo-youwillsee)</author><guid>https://ooooo-youwillsee.github.io/old-notes/geektime/mysql-45/03/</guid><description>1、事务隔离级别 事务的 ACID 中的 I 指的就是隔离性（Isolation）。 1、隔离级别 读未提交（read-uncommitted）：一个事务还没提</description></item><item><title/><link>https://ooooo-youwillsee.github.io/old-notes/geektime/mysql-45/04/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>297872913@qq.com (ooooo-youwillsee)</author><guid>https://ooooo-youwillsee.github.io/old-notes/geektime/mysql-45/04/</guid><description>1、索引的常见模型 1、哈希表 以键-值（key-value）存储数据的结构。只适用于等值查询的场景。 2、有序数组 查询效率高，但更新数据，成本高</description></item><item><title/><link>https://ooooo-youwillsee.github.io/old-notes/geektime/mysql-45/05/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>297872913@qq.com (ooooo-youwillsee)</author><guid>https://ooooo-youwillsee.github.io/old-notes/geektime/mysql-45/05/</guid><description>1、覆盖索引 创建表 T : 1 2 3 4 5 6 7 8 mysql&amp;gt; create table T ( ID int primary key, k int NOT NULL DEFAULT 0, s varchar(16) NOT NULL DEFAULT &amp;#39;&amp;#39;, index k(k)) engine=InnoDB; insert into T values(100,1, &amp;#39;aa&amp;#39;),(200,2,&amp;#39;bb&amp;#39;),(300,3,&amp;#39;cc&amp;#39;),(500,5,&amp;#39;ee&amp;#39;),(600,6,&amp;#39;ff&amp;#39;),(700,7,&amp;#39;gg&amp;#39;); 执行语句 select ID from T where k between 3 and 5，只需要扫描 k 索</description></item><item><title/><link>https://ooooo-youwillsee.github.io/old-notes/geektime/mysql-45/06/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>297872913@qq.com (ooooo-youwillsee)</author><guid>https://ooooo-youwillsee.github.io/old-notes/geektime/mysql-45/06/</guid><description>1、全局表 根据加锁的范围，MySQL 里面的锁大致可以分成全局锁、表级锁和行锁三类。 MySQL 加全局读锁的命令：flush tables with read lock;（FTWRL</description></item><item><title/><link>https://ooooo-youwillsee.github.io/old-notes/geektime/mysql-45/07/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>297872913@qq.com (ooooo-youwillsee)</author><guid>https://ooooo-youwillsee.github.io/old-notes/geektime/mysql-45/07/</guid><description>1、行锁 MySQL 的行锁是在引擎层由各个引擎自己实现的，并不是所有的引擎都支持行锁，比如 MyISAM 引擎就不支持，InnoDB 引擎支持行锁。 两阶段锁： 实际上事</description></item><item><title/><link>https://ooooo-youwillsee.github.io/old-notes/geektime/mysql-45/08/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>297872913@qq.com (ooooo-youwillsee)</author><guid>https://ooooo-youwillsee.github.io/old-notes/geektime/mysql-45/08/</guid><description>1、事务 在第 3 篇文章和你讲事务隔离级别的时候提到过，如果是可重复读隔离级别，事务 T 启动的时候会创建一个视图 read-view，之后事务 T 执行</description></item><item><title/><link>https://ooooo-youwillsee.github.io/old-notes/geektime/mysql-45/09/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>297872913@qq.com (ooooo-youwillsee)</author><guid>https://ooooo-youwillsee.github.io/old-notes/geektime/mysql-45/09/</guid><description>1、查询过程 主键索引 ID 和 普通索引 K: 假设执行查询的语句是 select id from T where k=5, 使用二分法查询： 对于普通索引来说，查找到满足条件的第一个记录(5,500)</description></item><item><title/><link>https://ooooo-youwillsee.github.io/old-notes/geektime/mysql-45/10/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>297872913@qq.com (ooooo-youwillsee)</author><guid>https://ooooo-youwillsee.github.io/old-notes/geektime/mysql-45/10/</guid><description>1、选错索引 一个例子，建表语句如下： 1 2 3 4 5 6 7 8 CREATE TABLE `x` ( `id` int(11) NOT NULL, `a` int(11) DEFAULT NULL, `b` int(11) DEFAULT NULL, PRIMARY KEY (`id`), KEY `a` (`a`), KEY `b` (`b`) ) ENGINE=InnoDB; 往表 x 中插入 10 万行记录，取值按整数</description></item><item><title/><link>https://ooooo-youwillsee.github.io/old-notes/geektime/mysql-45/11/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>297872913@qq.com (ooooo-youwillsee)</author><guid>https://ooooo-youwillsee.github.io/old-notes/geektime/mysql-45/11/</guid><description>1、字符串索引 假设，你现在维护一个支持邮箱登录的系统，用户表是这么定义的 1 2 3 4 5 mysql&amp;gt; create table SUser( ID bigint unsigned primary key, email varchar(64), ... )engine=innodb; 要使用邮箱登录，一定会出现类似下</description></item><item><title/><link>https://ooooo-youwillsee.github.io/old-notes/geektime/mysql-45/12/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>297872913@qq.com (ooooo-youwillsee)</author><guid>https://ooooo-youwillsee.github.io/old-notes/geektime/mysql-45/12/</guid><description>1、SQL语句为什么变&amp;quot;慢&amp;quot;了 在前面第 2 篇文章《日志系统：一条SQL更新语句是如何执行的？》中，InnoDB 在处理更新语</description></item><item><title/><link>https://ooooo-youwillsee.github.io/old-notes/geektime/mysql-45/readme/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>297872913@qq.com (ooooo-youwillsee)</author><guid>https://ooooo-youwillsee.github.io/old-notes/geektime/mysql-45/readme/</guid><description>MySQL 实战 45 讲 01、SQL 查询语句的执行过程</description></item></channel></rss>