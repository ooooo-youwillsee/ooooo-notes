<!doctype html><html itemscope itemtype=http://schema.org/WebPage lang=zh-CN><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=2"><meta name=robots content="noodp"><title>- 线偶的IT笔记</title><meta name=author content="线偶">
<meta name=author-link content><meta name=description content="1、kafka概念 ​ Apache Kafka是一款开源的消息引擎系统，也是一个分布式流处理平台；消息引擎系统是一组规范，企业利用这组规范在不同系统之间传"><meta itemprop=name content="线偶的IT笔记"><meta itemprop=description content="1、kafka概念 ​ Apache Kafka是一款开源的消息引擎系统，也是一个分布式流处理平台；消息引擎系统是一组规范，企业利用这组规范在不同系统之间传"><meta itemprop=dateModified content="2022-09-03T20:43:08+08:00"><meta itemprop=wordCount content="7424"><meta itemprop=image content="https://ooooo-youwillsee.github.io/logo.png"><meta property="og:url" content="https://ooooo-youwillsee.github.io/ooooo-notes/old-notes/geektime/java-core-36/04/"><meta property="og:site_name" content="线偶的IT笔记"><meta property="og:title" content="线偶的IT笔记"><meta property="og:description" content="1、kafka概念 ​ Apache Kafka是一款开源的消息引擎系统，也是一个分布式流处理平台；消息引擎系统是一组规范，企业利用这组规范在不同系统之间传"><meta property="og:locale" content="zh_CN"><meta property="og:type" content="article"><meta property="article:section" content="old-notes"><meta property="article:modified_time" content="2022-09-03T20:43:08+08:00"><meta property="og:image" content="https://ooooo-youwillsee.github.io/logo.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://ooooo-youwillsee.github.io/logo.png"><meta name=twitter:title content="线偶的IT笔记"><meta name=twitter:description content="1、kafka概念 ​ Apache Kafka是一款开源的消息引擎系统，也是一个分布式流处理平台；消息引擎系统是一组规范，企业利用这组规范在不同系统之间传"><meta name=application-name content="线偶的IT笔记"><meta name=apple-mobile-web-app-title content="线偶的IT笔记"><meta name=theme-color data-light=#f8f8f8 data-dark=#252627 content="#f8f8f8"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=canonical href=https://ooooo-youwillsee.github.io/ooooo-notes/old-notes/geektime/java-core-36/04/><link rel=prev href=https://ooooo-youwillsee.github.io/ooooo-notes/old-notes/geektime/java-core-36/readme/><link rel=next href=https://ooooo-youwillsee.github.io/ooooo-notes/old-notes/geektime/java-core-36/03/><link rel=stylesheet href=/ooooo-notes/css/style.min.css><link rel=preload href=/ooooo-notes/lib/fontawesome-free/all.min.css as=style onload='this.removeAttribute("onload"),this.rel="stylesheet"'><noscript><link rel=stylesheet href=/ooooo-notes/lib/fontawesome-free/all.min.css></noscript><link rel=preload href=/ooooo-notes/lib/animate/animate.min.css as=style onload='this.removeAttribute("onload"),this.rel="stylesheet"'><noscript><link rel=stylesheet href=/ooooo-notes/lib/animate/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/ooooo-youwillsee.github.io\/ooooo-notes\/old-notes\/geektime\/java-core-36\/04\/"},"genre":"old-notes","wordcount":7424,"url":"https:\/\/ooooo-youwillsee.github.io\/ooooo-notes\/old-notes\/geektime\/java-core-36\/04\/","dateModified":"2022-09-03T20:43:08+08:00","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"线偶"},"description":""}</script></head><body data-header-desktop=sticky data-header-mobile=auto><script>(window.localStorage?.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("data-theme","dark")</script><div class=wrapper data-page-style=normal><header class="desktop animate__faster" id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ooooo-notes/ title=线偶的IT笔记><span class=header-title-pre><i class='far fa-kiss-wink-heart fa-fw' aria-hidden=true></i></span><span class=header-title-text>线偶</span></a><span class="typeit header-subtitle"><template>Hello World</template></span></div><nav><ul class=menu><li class=menu-item><a class=menu-link href=/ooooo-notes/posts/><i class='fa fa-list' aria-hidden=true></i> 文章</a></li><li class=menu-item><a class=menu-link href=/ooooo-notes/tags/><i class='fa fa-tags' aria-hidden=true></i> 标签</a></li><li class=menu-item><a class=menu-link href=/ooooo-notes/collections/><i class='fa fa-archive' aria-hidden=true></i> 合集</a></li><li class=menu-item><a class=menu-link href=https://github.com/ooooo-youwillsee title=GitHub rel="noopener noreferrer" target=_blank><i class='fab fa-github fa-fw' aria-hidden=true></i></a></li><li class="menu-item delimiter"></li><li class="menu-item search" id=search-desktop><input type=text placeholder=搜索文章标题或内容…… id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fa-solid fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-desktop><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></li><li class="menu-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></li></ul></nav></div></header><header class="mobile animate__faster" id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ooooo-notes/ title=线偶的IT笔记><span class=header-title-pre><i class='far fa-kiss-wink-heart fa-fw' aria-hidden=true></i></span><span class=header-title-text>线偶</span></a><span class="typeit header-subtitle"><template>Hello World</template></span></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><nav><ul class=menu id=menu-mobile><li class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=搜索文章标题或内容…… id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fa-solid fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-mobile><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></li><li class=menu-item><a class=menu-link href=/ooooo-notes/posts/><i class='fa fa-list' aria-hidden=true></i> 文章</a></li><li class=menu-item><a class=menu-link href=/ooooo-notes/tags/><i class='fa fa-tags' aria-hidden=true></i> 标签</a></li><li class=menu-item><a class=menu-link href=/ooooo-notes/collections/><i class='fa fa-archive' aria-hidden=true></i> 合集</a></li><li class=menu-item><a class=menu-link href=https://github.com/ooooo-youwillsee title=GitHub rel="noopener noreferrer" target=_blank><i class='fab fa-github fa-fw' aria-hidden=true></i></a></li><li class="menu-item menu-system"><span class="menu-system-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></span></li></ul></nav></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><nav aria-label=breadcrumb class="breadcrumb-container sticky"><ol class=breadcrumb><li class=breadcrumb-item><a href=/ooooo-notes/old-notes/ title=Old-Notes>Old-Notes</a></li><li class="breadcrumb-item active" aria-current=page></li></ol></nav><main class=container><article class="page single special"><div class=header><h1 class="single-title animate__animated animate__pulse animate__faster"></h1></div><div class=content id=content><h2 id=1kafka概念 class=heading-element><span>1、kafka概念</span>
<a href=#1kafka%e6%a6%82%e5%bf%b5 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><p>​ Apache Kafka是一款开源的消息引擎系统，也是一个分布式流处理平台；消息引擎系统是一组规范，企业利用这组规范在不同系统之间传递语义准确的消息，实现松耦合的异步式数据传输。</p><h2 id=2kafka特点 class=heading-element><span>2、kafka特点</span>
<a href=#2kafka%e7%89%b9%e7%82%b9 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><ul><li>使用纯二进制的字节序列</li><li>同时支持两种消息引擎模型（点对点、发布/订阅）</li></ul><h2 id=3kafka的架构 class=heading-element><span>3、kafka的架构</span>
<a href=#3kafka%e7%9a%84%e6%9e%b6%e6%9e%84 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><ul><li>Topic：主题，承载消息的逻辑容器，用来区分业务；</li><li>Producer：生产者，向主题发布新消息的应用程序；</li><li>Consumer：消费者，向主题订阅新消息的应用程序；</li><li>Partition：分区，每个Topic可以设置多个分区；</li><li>Replica：副本，同一个消息以提供数据冗余可以有多个副本，分为领导者副本（可对外提供服务）和追随者副本（不可以对外提供服务）；对于分区实现高可用；</li><li>Consumer Group：消费者组，多个消费者可组成一个消费者组，同时消费多个分区实现高吞吐；同一个消费者组内的消费者不可重复消费同一分区的消息；</li><li>Rebalance：重平衡，消费者组内的某个消费者挂掉后，会重新分配订阅主题分区；</li><li>Offset：位移，有分区位移和消费者位移两个概念；分区位移是消息的位置标记（从0开始），是固定的；消费者位移是消费者在订阅消息时的消费进度，是动态的；</li></ul><p>图解partition和replication的概念</p><p><img loading=lazy src=imgs/partition%e5%92%8creplica.png alt=imgs/partition和replica.png srcset="imgs/partition%e5%92%8creplica.png?size=small, imgs/partition%e5%92%8creplica.png?size=medium 1.5x, imgs/partition%e5%92%8creplica.png?size=large 2x" data-title=imgs/partition和replica.png style="background:url(/ooooo-notes/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></p><h2 id=4多种kafka对比 class=heading-element><span>4、多种Kafka对比</span>
<a href=#4%e5%a4%9a%e7%a7%8dkafka%e5%af%b9%e6%af%94 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><ul><li>Apache Kafka：社区版kafka；迭代速度快，社区响应快，但是仅提供核心功能，缺少高级特性；</li><li>Confluent Kafka：Confluent公司提供的Kafka；集成了很多高级特性，分免费版和收费版，但是相关资料不全，普及率低；</li><li>CDH/HDP Kafka：大数据平台内嵌的Apache Kafka，操作简单，节省运维成本，但是把控度低，演进速度慢；</li></ul><h2 id=5kafka版本演变 class=heading-element><span>5、Kafka版本演变</span>
<a href=#5kafka%e7%89%88%e6%9c%ac%e6%bc%94%e5%8f%98 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><p>​ kafka版本命名规范：例kafka_2.11-2.1.1.tgz（2.11表示scala版本，2.1.1表示kafka版本）</p><pre><code>kafka版本号规范：大版本号 - 小版本号 - Patch 号（修订号）
</code></pre><ul><li>0.7版本：只提供最基础的消息队列功能；</li><li>0.8版本：引入了副本机制， 成为了一个真正意义上完备的分布式高可靠消息队列解决方案；（但是生产和消费的客户端还是老版本的，应指定zk地址而不是broker地址）；</li><li>0.8.2.0版本：引入了新版本Producer API（但是bug还有点多，不建议使用）；</li><li>0.8.2.2版本：老版本的Consumer API比较稳定了；</li><li>0.9版本：增加了基础的安全认证/权限功能，同时使用java重写了Consumer API，还引入了Kafka Connect组件用于实现高性能的数据抽取；另外新版本的Producer API比较稳定了，不建议使用新版本的Consumer API；</li><li>0.10版本：引入了Kafka Streams，正式升级为分布式流处理平台；</li><li>0.10.2.2版本：新版本的Consumer API比较稳定了，该版本也修复了一个可能导致Producer性能降低的bug；</li><li>0.11版本：提供了幂等性Producer API（幂等性就是消息去重，默认不开启）和事务API（实现流处理结果正确性的基石），还对Kafka消息格式做了重构；（该版本也是主流版本）；</li><li>0.11.0.3版本：消息引擎功能非常完善了；</li><li>1.1版本：实现故障转移（即Failover）；</li><li>1.0版本和2.0版本：只要是是对Kafka Streams的改进；</li></ul><h2 id=6kafka的核心参数 class=heading-element><span>6、Kafka的核心参数</span>
<a href=#6kafka%e7%9a%84%e6%a0%b8%e5%bf%83%e5%8f%82%e6%95%b0 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><h3 id=1配置文件参数 class=heading-element><span>1、配置文件参数</span>
<a href=#1%e9%85%8d%e7%bd%ae%e6%96%87%e4%bb%b6%e5%8f%82%e6%95%b0 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><ul><li>log.dirs：指定broker需要使用的若干个文件目录路径，无默认值；生产环境必须配置，CSV格式（例如：/home/kafka1,/home/kafka2）</li><li>zookeeper.connect：指定zk的地址和端口（例hadoop01:2181,hadoop02:2181,hadoop03:2181），zk保存了topic、分区的信息等等，如果多个kafka集群共有一个zk集群，加上chroot即可，chroot是别名，则指定格式为hadoop01:2181,hadoop02:2181,hadoop03:2181/kafka1或hadoop01:2181,hadoop02:2181,hadoop03:2181/kafka2;</li><li>listeners：监听器，指定协议、主机名、端口；</li><li>advertised.listeners：指该监听器是broker对外发布的；</li><li>host.name/port：过期参数，可以不指定；</li><li>auto.create.topics.enable：是否允许自动创建topic；</li><li>unclean.leader.election.enable：是否允许unclean leader选举，原本数据多的分区才有资格选举leader，该参数设置为true后，数据少的也可以参与选举，会造成数据丢失，建议设置为false；</li><li>auto.leader.rebalance.enable：是否允许定期选举leader，不建议开启；</li><li>log.retention.{hour|minutes|ms}：控制一条消息被保存多长时间，ms优先级最高；</li><li>log.retention.bytes：指定broker为消息保存的总磁盘容量大小，默认值为-1，表示没有上限；</li><li>message.max.bytes：控制broker能够接收的最大消息大小，默认值为1000012，太小，建议重设置；</li></ul><h3 id=2topic级别参数 class=heading-element><span>2、Topic级别参数</span>
<a href=#2topic%e7%ba%a7%e5%88%ab%e5%8f%82%e6%95%b0 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><ul><li><p>retention.ms：规定了该topic消息被保存的时长；</p></li><li><p>retention.bytes：规定了要为该topic预留多大的磁盘空间（默认-1，表示没有上限）；</p></li><li><p>max.message.bytes：Broker能够接收的该topic的最大消息大小；</p><p>以上参数可以通过两种方式设置</p><ol><li>创建topic时进行设置：例bin/kafka-topics.sh &ndash;zookeeper hadoop01:2181,hadoop02:2181,hadoop03:2181 &ndash;create &ndash;topic my-topic &ndash;partitions 1 &ndash;replication-factor 1 &ndash;config max.message.bytes=64000 &ndash;config flush.messages=1</li><li>修改topic时设置：例bin/kafka-topics.sh &ndash;zookeeper hadoop01:2181,hadoop02:2181,hadoop03:2181 &ndash;alter &ndash;topic my-topic &ndash;config max.message.bytes=128000</li></ol></li></ul><h3 id=3jvm参数 class=heading-element><span>3、JVM参数</span>
<a href=#3jvm%e5%8f%82%e6%95%b0 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><ul><li><p>KAFKA_HEAP_OPTS：指定堆大小；</p></li><li><p>KAFKA_JVM_PERFORMANCE_OPTS：指定GC参数；</p><p>在启动kafka前设置这两个环境变量。</p></li></ul><h3 id=4操作系统参数 class=heading-element><span>4、操作系统参数</span>
<a href=#4%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e5%8f%82%e6%95%b0 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><ul><li>ulimit -n：打开文件描述符最大值（例ulimit -n 100000）；</li><li>文件系统类型：建议选择XFS；</li><li>swappniess：swap空间大小，建议设置略大于0的值；</li><li>提交时间：即flush落盘时间，kafka的数据会先写到操作系统的页缓存上，然后会根据LRU算法定期将页缓存的数据落盘到磁盘，默认为5秒，可适当增大时间间隔；</li></ul><h2 id=7分区策略 class=heading-element><span>7、分区策略</span>
<a href=#7%e5%88%86%e5%8c%ba%e7%ad%96%e7%95%a5 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><h3 id=1生产者分区策略 class=heading-element><span>1、生产者分区策略</span>
<a href=#1%e7%94%9f%e4%ba%a7%e8%80%85%e5%88%86%e5%8c%ba%e7%ad%96%e7%95%a5 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><ul><li>轮询策略（Round-robin）：kafka生产者API默认的分区策略，最大限度负载均衡；</li><li>随机策略（Randomness）：可自定义实现该策略；</li><li>按消息键保存策略（Key-ordering）：key可以是业务上的字段信息，按业务场景自定义分区；</li></ul><h3 id=2消费者分区策略 class=heading-element><span>2、消费者分区策略</span>
<a href=#2%e6%b6%88%e8%b4%b9%e8%80%85%e5%88%86%e5%8c%ba%e7%ad%96%e7%95%a5 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><ul><li><p>按范围分配：指定分区消费；</p></li><li><p>轮询分配：按顺序分配给消费者；</p></li><li><p>自定义：设置partition.assignment.strategy为自定义的类；</p></li></ul><h2 id=8压缩 class=heading-element><span>8、压缩</span>
<a href=#8%e5%8e%8b%e7%bc%a9 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><p>​ kafka的消息层次分为消息集合和消息。一个消息集合包含若干条日志项，日志项就是装消息的地方；kafka底层的消息日志由一系列消息集合日志项组成，kafka是在消息集合层面上进行写入操作；</p><h3 id=1kafka消息格式 class=heading-element><span>1、kafka消息格式</span>
<a href=#1kafka%e6%b6%88%e6%81%af%e6%a0%bc%e5%bc%8f class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>​ kafka有两大消息格式：V1和V2（0.11.0.0版本后引入的）；</p><p>​ V1中每条消息需要执行CRC校验，但是在某些情况下CRC值是会变化的，会浪费空间和耽误CPU时间；在保存压缩消息上，是把多条消息进行压缩然后保存到外层消息的消息体字段中。</p><p>​ V2对V1改进了很多，CRC校验工作移到了消息集合这一层，而且在保存压缩消息上，是对整个消息集合进行压缩。</p><h3 id=2何时压缩和解压缩 class=heading-element><span>2、何时压缩和解压缩</span>
<a href=#2%e4%bd%95%e6%97%b6%e5%8e%8b%e7%bc%a9%e5%92%8c%e8%a7%a3%e5%8e%8b%e7%bc%a9 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><ul><li>生产者端：生产消息时指定压缩方法。</li><li>broker端：默认的压缩方式是producer，如果指定了跟producer不同的压缩方式时，会先解压缩再按新指定的方式压缩；或者broker端发生了消息格式转换也会重压缩。</li><li>consumer端：解压缩。</li></ul><h3 id=3压缩算法 class=heading-element><span>3、压缩算法</span>
<a href=#3%e5%8e%8b%e7%bc%a9%e7%ae%97%e6%b3%95 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>（kafka2.1.0版本前支持的算法：GZIP、Snappy、LZ4；该版本开始后支持Zstandard算法）</p><p>压缩算法的优劣有两个指标：压缩比和压缩/解压缩吞吐量；</p><ul><li>压缩比：zstd > LZ4 > GZIP > Snappy</li><li>吞吐量：LZ4 > Snappy > zstd / GZIP</li></ul><h2 id=9无消息丢失配置 class=heading-element><span>9、无消息丢失配置</span>
<a href=#9%e6%97%a0%e6%b6%88%e6%81%af%e4%b8%a2%e5%a4%b1%e9%85%8d%e7%bd%ae class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><p>kafka只对已提交的消息做有限度的持久化保证。</p><ul><li>不要使用producer.send(msg),而要使用producer.send(msg,callback);</li><li>设置acks = all；表明所有副本broker都要接收到消息，保证消息”已提交“；</li><li>设置retries为一个较大的值；</li><li>设置unclean.leader.election.enable = false；表示禁止落后的broker被选为leader。</li><li>设置replication.factor >= 3；</li><li>设置min.insync.replicas > 1；控制消息至少被写入多少个副本才算“已提交”；</li><li>确保replication.factor > min.insync.replicas；推荐replication.factor = min.insync.replicas + 1；</li><li>设置enable.auto.commit = false；确保消息消费完成再提交；</li></ul><h2 id=10幂等性和事务性 class=heading-element><span>10、幂等性和事务性</span>
<a href=#10%e5%b9%82%e7%ad%89%e6%80%a7%e5%92%8c%e4%ba%8b%e5%8a%a1%e6%80%a7 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><p>​ 幂等性：指某些操作执行一次或多次的结果是一样的，在kafka中是对重复消息去重。</p><p>​ 引入事务的作用：1、 生产者多次发送消息可以封装成一个原子操作，要么都成功，要么失败；2、 consumer-transform-producer模式下，因为消费者提交偏移量出现问题，导致在重复消费消息时，生产者重复生产消息。需要将这个模式下消费者提交偏移量操作和生产者一系列生成消息的操作封装成一个原子操作。</p><p>​ kafka事务一般为两种：1、 只有Producer生产消息 ；2、生产消费并存（consumer-transform-producer）；3、只有Consumer消费消息。</p><ul><li><p>幂等性Producer：只能保证单分区、单会话上的消息幂等性（设置幂等性：props.put(&ldquo;enable.idempotence&rdquo;, true)或props.put(ProducerConfig.ENABLE_IDEMPOTENCE_CONFIG, true)）</p><p>事务提供的ACID特性：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）</p><p>隔离性：表示并发执行的事务彼此相互隔离，互不影响。</p></li><li><p>事务型Producer：能够保证跨分区、跨会话间的幂等性(设置事务型Producer：开启enable.idempotence = true，然后设置Producer端参数transctional.id,还要调用一些事务API，如下列代码；表示record1和record2要么全部写入成功要么失败。在consumer端要设置isolation.level，read_uncommitted是默认值，表示可以读取到kafka任何消息，不管事务型Producer是提交事务还是终止事务；建议使用read_committed，表示只读取事务型成功提交的消息以及非事务型Producer写入的消息。)</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>producer</span><span class=p>.</span><span class=na>initTransactions</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>try</span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=n>producer</span><span class=p>.</span><span class=na>beginTransaction</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=n>producer</span><span class=p>.</span><span class=na>send</span><span class=p>(</span><span class=n>record1</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=n>producer</span><span class=p>.</span><span class=na>send</span><span class=p>(</span><span class=n>record2</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=n>producer</span><span class=p>.</span><span class=na>commitTransaction</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=k>catch</span><span class=p>(</span><span class=n>KafkaException</span><span class=w> </span><span class=n>e</span><span class=p>){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>producer</span><span class=p>.</span><span class=na>abortTransaction</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span></span></span></code></pre></td></tr></table></div></div></li></ul><h2 id=11consumer-group class=heading-element><span>11、Consumer Group</span>
<a href=#11consumer-group class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><h3 id=1特性 class=heading-element><span>1、特性</span>
<a href=#1%e7%89%b9%e6%80%a7 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><ul><li><p>一个Consumer Group可以有一个或多个Consumer；</p></li><li><p>Droup ID是一个字符串，标识这一个唯一的Consumer Group；</p></li><li><p>同一个Group中的Consumer不能重复订阅一个分区；</p><p>（老版本的Consumer Group把消费者位移保存在zk中，由于频繁读写会导致zk集群性能降低，新版本把消费者位移保存在kafka的_consumer_offsets的topic中。）</p></li></ul><h3 id=2rebalance的触发条件 class=heading-element><span>2、rebalance的触发条件</span>
<a href=#2rebalance%e7%9a%84%e8%a7%a6%e5%8f%91%e6%9d%a1%e4%bb%b6 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><ul><li>Consumer Group中的成员数变更；</li><li>订阅的topic数变更（比如订阅了用正则匹配的topic，新增了一个符合的topic）；</li><li>订阅的topic的分区数变更；</li></ul><h3 id=3rebalance的弊端 class=heading-element><span>3、rebalance的弊端</span>
<a href=#3rebalance%e7%9a%84%e5%bc%8a%e7%ab%af class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><ul><li>rebalance影响Consumer端TPS；（rebalance期间，consumer会停止工作）</li><li>rebalance过程很慢；</li><li>rebalance效率不高；</li></ul><h3 id=4非必要rebalance class=heading-element><span>4、非必要rebalance</span>
<a href=#4%e9%9d%9e%e5%bf%85%e8%a6%81rebalance class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><ul><li><p>consumer未能及时给coordinator发送心跳，导致consumer被踢出Consumer Group；需设置合理的session.timeout.ms（默认值是10s，表示coordinator在10s内没收到consumer的心跳消息，该consumer被判定为dead）和heartbeat.interval.ms（表示consumer发送心跳请求的频率）的值</p><p>（推荐session.timeout.ms=2s，heartbeat.interval.ms=6s）</p></li><li><p>consumer消费时间过长；需设置max.poll.interval.ms的值，表示下游处理数据的时间；</p></li></ul><h2 id=12位移主题_consumer_offsets class=heading-element><span>12、位移主题（_consumer_offsets）</span>
<a href=#12%e4%bd%8d%e7%a7%bb%e4%b8%bb%e9%a2%98_consumer_offsets class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><p>​ _consumer_offsets的主要作用就是保存Kafka消费者的位移消息。消息格式是KV对，Key保存的是&lt;Group ID,主题名，分区号>；另外还有两种消息格式：1.用于保存Consumer Group信息的消息；2.用于删除Group过期位移甚至是删除Group的消息。</p><p>​ 当有第一个Consumer消费数据时，Kafka就会自动创建_consumer_offsets这个主题，默认有50个分区，3个副本。</p><h2 id=13提交位移 class=heading-element><span>13、提交位移</span>
<a href=#13%e6%8f%90%e4%ba%a4%e4%bd%8d%e7%a7%bb class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><p>​ 从用户角度，分为自动提交和手动提交；从Consumer角度分为同步提交和异步提交。 <em>org.apache.kafka.common.serialization.String</em>Serializer</p><ul><li><p>自动提交</p><p>设置为自动提交后，调用poll方法时，会提交上次poll返回的所有消息，poll方法的逻辑是先提交上一批消息的位移，再处理下一批消息，可以保证不出现消费丢失的情况，缺点是可能出现重复消费。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>Properties</span><span class=w> </span><span class=n>props</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Properties</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>props</span><span class=p>.</span><span class=na>put</span><span class=p>(</span><span class=s>&#34;bootstrap.servers&#34;</span><span class=p>,</span><span class=s>&#34;localhost:9092&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>props</span><span class=p>.</span><span class=na>put</span><span class=p>(</span><span class=s>&#34;group.id&#34;</span><span class=p>,</span><span class=s>&#34;test&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>props</span><span class=p>.</span><span class=na>put</span><span class=p>(</span><span class=s>&#34;enable.auto.commit&#34;</span><span class=p>,</span><span class=s>&#34;true&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>props</span><span class=p>.</span><span class=na>put</span><span class=p>(</span><span class=s>&#34;auto.commit.interval.ms&#34;</span><span class=p>,</span><span class=s>&#34;2000&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>props</span><span class=p>.</span><span class=na>put</span><span class=p>(</span><span class=s>&#34;key.deserializer&#34;</span><span class=p>,</span><span class=s>&#34;org.apache.kafka.common.serialization.String*Serializer&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>props</span><span class=p>.</span><span class=na>put</span><span class=p>(</span><span class=s>&#34;value.deserializer&#34;</span><span class=p>,</span><span class=s>&#34;org.apache.kafka.common.serialization.String*Serializer&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>KafkaConsumer</span><span class=o>&lt;</span><span class=n>String</span><span class=p>,</span><span class=n>String</span><span class=o>&gt;</span><span class=w> </span><span class=n>consumer</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>KafkaConsumer</span><span class=o>&lt;&gt;</span><span class=p>(</span><span class=n>props</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>consumer</span><span class=p>.</span><span class=na>subscribe</span><span class=p>(</span><span class=n>Arrays</span><span class=p>.</span><span class=na>asList</span><span class=p>(</span><span class=s>&#34;foo&#34;</span><span class=p>,</span><span class=s>&#34;bar&#34;</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>while</span><span class=p>(</span><span class=kc>true</span><span class=p>){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>ConsumerRecords</span><span class=o>&lt;</span><span class=n>String</span><span class=p>,</span><span class=n>String</span><span class=o>&gt;</span><span class=w> </span><span class=n>records</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>consumer</span><span class=p>.</span><span class=na>poll</span><span class=p>(</span><span class=n>100</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>for</span><span class=p>(</span><span class=n>ConsumerRecord</span><span class=o>&lt;</span><span class=n>String</span><span class=p>,</span><span class=n>String</span><span class=o>&gt;</span><span class=w> </span><span class=n>record</span><span class=w> </span><span class=p>:</span><span class=w> </span><span class=n>records</span><span class=p>){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>printf</span><span class=p>(</span><span class=s>&#34;offset = %d, key = %s, value = %s%n&#34;</span><span class=p>,</span><span class=w> </span><span class=n>record</span><span class=p>.</span><span class=na>offset</span><span class=p>(),</span><span class=w> </span><span class=n>record</span><span class=p>.</span><span class=na>key</span><span class=p>(),</span><span class=w> </span><span class=n>resord</span><span class=p>.</span><span class=na>value</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span></span></span></code></pre></td></tr></table></div></div></li><li><p>同步提交commitSync()</p><p>手动提交在调用commitSync()时，Consumer会处于阻塞状态，直到Broker端返回结果，影响整个程序的TPS。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=k>while</span><span class=p>(</span><span class=kc>true</span><span class=p>){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>ConsumerRecords</span><span class=o>&lt;</span><span class=n>String</span><span class=p>,</span><span class=n>String</span><span class=o>&gt;</span><span class=w> </span><span class=n>records</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>consumer</span><span class=p>.</span><span class=na>poll</span><span class=p>(</span><span class=n>Duration</span><span class=p>.</span><span class=na>ofSeconds</span><span class=p>(</span><span class=n>1</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>process</span><span class=p>(</span><span class=n>records</span><span class=p>);</span><span class=w>	</span><span class=c1>//处理消息</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>try</span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>consumer</span><span class=p>.</span><span class=na>commitSync</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=k>catch</span><span class=w> </span><span class=p>(</span><span class=n>CommitFailedException</span><span class=w> </span><span class=n>e</span><span class=p>){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>handle</span><span class=p>(</span><span class=n>e</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span></span></span></code></pre></td></tr></table></div></div></li><li><p>异步提交commitAsync()</p><p>在调用commitAsync()时，会立即返回结果，不会阻塞；缺点是出现问题时不能自动重试。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=k>while</span><span class=p>(</span><span class=kc>true</span><span class=p>){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>ConsumerRecords</span><span class=o>&lt;</span><span class=n>String</span><span class=p>,</span><span class=n>String</span><span class=o>&gt;</span><span class=w> </span><span class=n>records</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>consumer</span><span class=p>.</span><span class=na>poll</span><span class=p>(</span><span class=n>Duration</span><span class=p>.</span><span class=na>ofSeconds</span><span class=p>(</span><span class=n>1</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>process</span><span class=p>(</span><span class=n>records</span><span class=p>);</span><span class=w>	</span><span class=c1>//处理消息</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>consumer</span><span class=p>.</span><span class=na>commitAsync</span><span class=p>((</span><span class=n>offsets</span><span class=p>,</span><span class=n>exception</span><span class=p>)</span><span class=w> </span><span class=o>-&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>if</span><span class=p>(</span><span class=n>exception</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>null</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>handle</span><span class=p>(</span><span class=n>exception</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>});</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span></span></span></code></pre></td></tr></table></div></div></li><li><p>同步+异步提交</p><p>手动提交中，commitSync()和commitAsync()结合使用会有很好的效果，利用commitSync()的自动重试避免瞬时错误，利用commitAsync()不会阻塞。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=k>try</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> 	</span><span class=k>while</span><span class=w> </span><span class=p>(</span><span class=kc>true</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> 		</span><span class=n>ConsumerRecords</span><span class=o>&lt;</span><span class=n>String</span><span class=p>,</span><span class=w> </span><span class=n>String</span><span class=o>&gt;</span><span class=w> </span><span class=n>records</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>consumer</span><span class=p>.</span><span class=na>poll</span><span class=p>(</span><span class=n>Duration</span><span class=p>.</span><span class=na>ofSeconds</span><span class=p>(</span><span class=n>1</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> 		</span><span class=n>process</span><span class=p>(</span><span class=n>records</span><span class=p>);</span><span class=w> </span><span class=c1>// 处理消息</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> 		</span><span class=n>commitAysnc</span><span class=p>();</span><span class=w> </span><span class=c1>// 使用异步提交规避阻塞</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> 	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w> </span><span class=k>catch</span><span class=w> </span><span class=p>(</span><span class=n>Exception</span><span class=w> </span><span class=n>e</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> 	</span><span class=n>handle</span><span class=p>(</span><span class=n>e</span><span class=p>);</span><span class=w> </span><span class=c1>// 处理异常</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w> </span><span class=k>finally</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> 	</span><span class=k>try</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> 		</span><span class=n>consumer</span><span class=p>.</span><span class=na>commitSync</span><span class=p>();</span><span class=w> </span><span class=c1>// 最后一次提交使用同步阻塞式提交</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w> </span><span class=k>finally</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> 		</span><span class=n>consumer</span><span class=p>.</span><span class=na>close</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><ul><li><p>同步/异步的细粒度提交</p><p>通常poll的数据全部处理完后再提交位移，如果poll的总数很大，而处理过程中出现差错了，下一次会重复消费，就需要设置细粒度的提交位移。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>private</span><span class=w> </span><span class=n>Map</span><span class=o>&lt;</span><span class=n>TopicPartition</span><span class=p>,</span><span class=w> </span><span class=n>OffsetAndMetadata</span><span class=o>&gt;</span><span class=w> </span><span class=n>offsets</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>HashMap</span><span class=o>&lt;&gt;</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kt>int</span><span class=w> </span><span class=n>count</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=err>……</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>while</span><span class=w> </span><span class=p>(</span><span class=kc>true</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> 	</span><span class=n>ConsumerRecords</span><span class=o>&lt;</span><span class=n>String</span><span class=p>,</span><span class=w> </span><span class=n>String</span><span class=o>&gt;</span><span class=w> </span><span class=n>records</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>consumer</span><span class=p>.</span><span class=na>poll</span><span class=p>(</span><span class=n>Duration</span><span class=p>.</span><span class=na>ofSeconds</span><span class=p>(</span><span class=n>1</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> 	</span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=n>ConsumerRecord</span><span class=o>&lt;</span><span class=n>String</span><span class=p>,</span><span class=w> </span><span class=n>String</span><span class=o>&gt;</span><span class=w> </span><span class=n>record</span><span class=p>:</span><span class=w> </span><span class=n>records</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> 	</span><span class=n>process</span><span class=p>(</span><span class=n>record</span><span class=p>);</span><span class=w> </span><span class=c1>// 处理消息</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=n>offsets</span><span class=p>.</span><span class=na>put</span><span class=p>(</span><span class=k>new</span><span class=w> </span><span class=n>TopicPartition</span><span class=p>(</span><span class=n>record</span><span class=p>.</span><span class=na>topic</span><span class=p>(),</span><span class=w> </span><span class=n>record</span><span class=p>.</span><span class=na>partition</span><span class=p>()),</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>OffsetAndMetadata</span><span class=p>(</span><span class=n>record</span><span class=p>.</span><span class=na>offset</span><span class=p>()</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>1</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> 	</span><span class=k>if</span><span class=err>（</span><span class=n>count</span><span class=w> </span><span class=o>%</span><span class=w> </span><span class=n>100</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>0</span><span class=err>）</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> 	</span><span class=n>consumer</span><span class=p>.</span><span class=na>commitAsync</span><span class=p>(</span><span class=n>offsets</span><span class=p>,</span><span class=w> </span><span class=kc>null</span><span class=p>);</span><span class=w> </span><span class=c1>// 回调处理逻辑是</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> 	</span><span class=n>count</span><span class=o>++</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span></span></span></code></pre></td></tr></table></div></div></li></ul></li></ul><h2 id=14commitfailedexception class=heading-element><span>14、CommitFailedException</span>
<a href=#14commitfailedexception class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><p>​ CommitFailedException是指Consumer客户端在提交位移时出现了错误或异常，而且不可恢复。</p><h3 id=1场景一 class=heading-element><span>1、场景一</span>
<a href=#1%e5%9c%ba%e6%99%af%e4%b8%80 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>​ 当消息处理的总时间超过预设的 max.poll.interval.ms 参数值时，Kafka Consumer 端会抛出 CommitFailedException 异常。</p><p>解决方法如代码：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=err>…</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>Properties</span><span class=w> </span><span class=n>props</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Properties</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=err>…</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>props</span><span class=p>.</span><span class=na>put</span><span class=p>(</span><span class=s>&#34;max.poll.interval.ms&#34;</span><span class=p>,</span><span class=w> </span><span class=n>5000</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>consumer</span><span class=p>.</span><span class=na>subscribe</span><span class=p>(</span><span class=n>Arrays</span><span class=p>.</span><span class=na>asList</span><span class=p>(</span><span class=s>&#34;test-topic&#34;</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>while</span><span class=w> </span><span class=p>(</span><span class=kc>true</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> 	</span><span class=n>ConsumerRecords</span><span class=o>&lt;</span><span class=n>String</span><span class=p>,</span><span class=w> </span><span class=n>String</span><span class=o>&gt;</span><span class=w> </span><span class=n>records</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>consumer</span><span class=p>.</span><span class=na>poll</span><span class=p>(</span><span class=n>Duration</span><span class=p>.</span><span class=na>ofSeconds</span><span class=p>(</span><span class=n>1</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> 	</span><span class=c1>// 使用 Thread.sleep 模拟真实的消息处理逻辑</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=n>Thread</span><span class=p>.</span><span class=na>sleep</span><span class=p>(</span><span class=n>6000L</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> 	</span><span class=n>consumer</span><span class=p>.</span><span class=na>commitSync</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>防止出现该异常的办法：</p><ul><li>缩短单条消息处理时间；</li><li>增加Comsumer端允许下游系统消费一批消息的最大时长（设置max.poll.interval.ms的值，在0.10.1.0版本后才有该参数）；</li><li>减少下游系统一次性消费的消息总数（设置max.poll.records的值）；</li><li>下游系统使用多线程加速消费；</li></ul><h3 id=2场景二 class=heading-element><span>2、场景二</span>
<a href=#2%e5%9c%ba%e6%99%af%e4%ba%8c class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>​ Standalone Consumer在消费时也需要指定groud.id，如果出现了一个相同group.id的Consumer Group，kafka也会抛出异常；这种情况很少见，目前没有解决办法，要尽量去避免。</p><h2 id=15多线程 class=heading-element><span>15、多线程</span>
<a href=#15%e5%a4%9a%e7%ba%bf%e7%a8%8b class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><p>​ kafka 0.10.1.0版本开始，KafkaConsumer就是双线程设计，即用户主线程和心跳线程；用户主线程就是启动Consumer应用程序main方法的那个程序，心跳线程只负责定期给对应的的Broker机器发送心跳请求，以标识消费者应用的存活性。所以在消费层面上，Consumer依然是单线程设计。</p><p>多线程方案：</p><p>方案一：</p><p>​ 消费者程序启动多个线程，每个线程维护专属的KafkaConsumer实例，负责完整的消息获取和消息处理流程；</p><p>优点：</p><ul><li>实现起来简单；</li><li>线程之间没有交互，省去保障线程安全的开销；</li><li>由于每个线程使用专属的Consumer实例执行消息获取和消息处理，可以保证分区内的消费顺序；</li></ul><p>缺点：</p><ul><li><p>由于每个线程要维护自己的Consumer实例，会占用很多系统资源；</p></li><li><p>线程数受限于Consumer订阅主题的总分区数；</p></li><li><p>如有某个线程处理较慢，会造成rebalance；</p><p>实现代码如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>KafkaConsumerRunner</span><span class=w> </span><span class=kd>implements</span><span class=w> </span><span class=n>Runnable</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> 	</span><span class=kd>private</span><span class=w> </span><span class=kd>final</span><span class=w> </span><span class=n>AtomicBoolean</span><span class=w> </span><span class=n>closed</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>AtomicBoolean</span><span class=p>(</span><span class=kc>false</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> 	</span><span class=kd>private</span><span class=w> </span><span class=kd>final</span><span class=w> </span><span class=n>KafkaConsumer</span><span class=w> </span><span class=n>consumer</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> 	</span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>run</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> 		</span><span class=k>try</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> 			</span><span class=n>consumer</span><span class=p>.</span><span class=na>subscribe</span><span class=p>(</span><span class=n>Arrays</span><span class=p>.</span><span class=na>asList</span><span class=p>(</span><span class=s>&#34;topic&#34;</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> 			</span><span class=k>while</span><span class=w> </span><span class=p>(</span><span class=o>!</span><span class=n>closed</span><span class=p>.</span><span class=na>get</span><span class=p>())</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>				</span><span class=n>ConsumerRecords</span><span class=w> </span><span class=n>records</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>consumer</span><span class=p>.</span><span class=na>poll</span><span class=p>(</span><span class=n>Duration</span><span class=p>.</span><span class=na>ofMillis</span><span class=p>(</span><span class=n>10000</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> 				</span><span class=c1>// 执行消息处理逻辑</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                 </span><span class=p>...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> 			</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> 		</span><span class=p>}</span><span class=w> </span><span class=k>catch</span><span class=w> </span><span class=p>(</span><span class=n>WakeupException</span><span class=w> </span><span class=n>e</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> 			</span><span class=c1>// Ignore exception if closing</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> 			</span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=o>!</span><span class=n>closed</span><span class=p>.</span><span class=na>get</span><span class=p>())</span><span class=w> </span><span class=k>throw</span><span class=w> </span><span class=n>e</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> 		</span><span class=p>}</span><span class=w> </span><span class=k>finally</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> 			</span><span class=n>consumer</span><span class=p>.</span><span class=na>close</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> 		</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> 	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> 	</span><span class=c1>// Shutdown hook which can be called from a separate thread</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> 	</span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>shutdown</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=n>closed</span><span class=p>.</span><span class=na>set</span><span class=p>(</span><span class=kc>true</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> 		</span><span class=n>consumer</span><span class=p>.</span><span class=na>wakeup</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> 	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span></span></span></code></pre></td></tr></table></div></div></li></ul><p>方案二：</p><p>​ 消费者程序使用单或多线程获取消息，同时创建多个消费线程执行消息处理逻辑；</p><p>优点：</p><ul><li>高伸缩性，自由调节消息获取和消息处理的线程数；</li></ul><p>缺点：</p><ul><li><p>实现难度大；</p></li><li><p>由于消息获取和消息处理解耦，会破坏消息在分区中的顺序；</p></li><li><p>会使得整个消息消费链路被拉长，位移提交可能会出错，导致重复消费；</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>private</span><span class=w> </span><span class=kd>final</span><span class=w> </span><span class=n>KafkaConsumer</span><span class=o>&lt;</span><span class=n>String</span><span class=p>,</span><span class=w> </span><span class=n>String</span><span class=o>&gt;</span><span class=w> </span><span class=n>consumer</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>private</span><span class=w> </span><span class=n>ExecutorService</span><span class=w> </span><span class=n>executors</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>private</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>workerNum</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>...;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>executors</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>ThreadPoolExecutor</span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=n>workerNum</span><span class=p>,</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>workerNum</span><span class=p>,</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>0L</span><span class=p>,</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>TimeUnit</span><span class=p>.</span><span class=na>MILLISECONDS</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>new</span><span class=w> </span><span class=n>ArrayBlockingQueue</span><span class=o>&lt;&gt;</span><span class=p>(</span><span class=n>1000</span><span class=p>),</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>new</span><span class=w> </span><span class=n>ThreadPoolExecutor</span><span class=p>.</span><span class=na>CallerRunsPolicy</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>while</span><span class=w> </span><span class=p>(</span><span class=kc>true</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=n>ConsumerRecords</span><span class=o>&lt;</span><span class=n>String</span><span class=p>,</span><span class=w> </span><span class=n>String</span><span class=o>&gt;</span><span class=w> </span><span class=n>records</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>consumer</span><span class=p>.</span><span class=na>poll</span><span class=p>(</span><span class=n>Duration</span><span class=p>.</span><span class=na>ofSeconds</span><span class=p>(</span><span class=n>1</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kd>final</span><span class=w> </span><span class=n>ConsumerRecord</span><span class=w> </span><span class=n>record</span><span class=w> </span><span class=p>:</span><span class=w> </span><span class=n>records</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=n>executors</span><span class=p>.</span><span class=na>submit</span><span class=p>(</span><span class=k>new</span><span class=w> </span><span class=n>Worker</span><span class=p>(</span><span class=n>record</span><span class=p>));</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>..</span></span></span></code></pre></td></tr></table></div></div></li></ul></div><div id=comments><div id=gitalk class=comment></div><noscript>Please enable JavaScript to view the comments powered by <a href=https://github.com/gitalk/gitalk rel="external nofollow noopener noreferrer">Gitalk</a>.</noscript></div></article></main><footer class=footer><div class=footer-container><div class="footer-line powered">由 <a href=https://gohugo.io/ target=_blank rel="external nofollow noopener noreferrer" title="Hugo 0.128.1"><img class=hugo-icon src=/ooooo-notes/images/hugo.min.svg alt="Hugo logo"> Hugo</a> 强力驱动 | 主题 - <a href=https://github.com/hugo-fixit/FixIt target=_blank rel=external title="FixIt v0.3.8-RC"><img class=fixit-icon src=/ooooo-notes/images/fixit.min.svg alt="FixIt logo"> FixIt</a></div><div class="footer-line copyright" itemscope itemtype=http://schema.org/CreativeWork><i class="fa-regular fa-copyright fa-fw" aria-hidden=true></i>
<span itemprop=copyrightYear>2022 - 2024</span><span class=author itemprop=copyrightHolder>
<a href=/ooooo-notes/>线偶</a></span><span class="license footer-divider"><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div><div class="footer-line visitor"><span id=busuanzi_container_site_uv title=总访客数><i class="fa-regular fa-user fa-fw" aria-hidden=true></i>&nbsp;<span id=busuanzi_value_site_uv><i class="fa-solid fa-spinner fa-spin fa-fw" aria-hidden=true></i></span></span><span id=busuanzi_container_site_pv class=footer-divider title=总访问量><i class="fa-regular fa-eye fa-fw" aria-hidden=true></i>&nbsp;<span id=busuanzi_value_site_pv><i class="fa-solid fa-spinner fa-spin fa-fw" aria-hidden=true></i></span></span></div></div></footer></div><div class=widgets><div class="fixed-buttons animate__faster d-none"><div class="fixed-button back-to-top" role=button aria-label=回到顶部><i class="fa-solid fa-arrow-up fa-fw" aria-hidden=true></i><span class=variant-numeric>0%</span></div><div class="fixed-button view-comments d-none" role=button aria-label=查看评论><i class="fa-solid fa-comment fa-fw" aria-hidden=true></i></div></div><div id=mask></div><div class=reading-progress-bar style=left:0;top:0></div><noscript><div class=noscript-warning>该网站在启用 JavaScript 的情况下效果最佳。</div></noscript></div><link rel=stylesheet href=/ooooo-notes/lib/gitalk/gitalk.min.css><link rel=stylesheet href=/ooooo-notes/lib/lightgallery/css/lightgallery-bundle.min.css><link rel=preload href=/ooooo-notes/lib/katex/katex.min.css as=style onload='this.removeAttribute("onload"),this.rel="stylesheet"'><noscript><link rel=stylesheet href=/ooooo-notes/lib/katex/katex.min.css></noscript><link rel=stylesheet href=/ooooo-notes/lib/cookieconsent/cookieconsent.min.css><link rel=stylesheet href=/ooooo-notes/lib/pace/themes/blue/pace-theme-minimal.css><script src=/ooooo-notes/lib/gitalk/gitalk.min.js></script><script src=/ooooo-notes/lib/autocomplete/autocomplete.min.js defer></script><script src=/ooooo-notes/lib/fuse/fuse.min.js defer></script><script src=/ooooo-notes/lib/twemoji/twemoji.min.js defer></script><script src=/ooooo-notes/lib/lightgallery/lightgallery.min.js defer></script><script src=/ooooo-notes/lib/lightgallery/plugins/thumbnail/lg-thumbnail.min.js defer></script><script src=/ooooo-notes/lib/lightgallery/plugins/zoom/lg-zoom.min.js defer></script><script src=/ooooo-notes/lib/sharer/sharer.min.js async defer></script><script src=/ooooo-notes/lib/typeit/index.umd.js defer></script><script src=/ooooo-notes/lib/katex/katex.min.js defer></script><script src=/ooooo-notes/lib/katex/auto-render.min.js defer></script><script src=/ooooo-notes/lib/katex/copy-tex.min.js defer></script><script src=/ooooo-notes/lib/katex/mhchem.min.js defer></script><script src=/ooooo-notes/lib/cookieconsent/cookieconsent.min.js defer></script><script src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js async defer></script><script src=/ooooo-notes/lib/pace/pace.min.js async defer></script><script>window.config={autoBookmark:!0,code:{copyTitle:"复制到剪贴板",editLockTitle:"锁定可编辑代码块",editUnLockTitle:"解锁可编辑代码块",editable:!0,maxShownLines:100},comment:{enable:!0,expired:!1,gitalk:{admin:["ooooo-youwillsee"],clientID:"9fcbefe148801287b34f",clientSecret:"3833b0f8bda400fb1ea7093446f340821394e501",id:"0001-01-01T00:00:00Z",owner:"ooooo-youwillsee",repo:"ooooo-notes-gitalk",title:""}},cookieconsent:{content:{dismiss:"同意",link:"了解更多",message:"本网站使用 Cookies 来改善您的浏览体验。"},enable:!0,palette:{button:{background:"#f0f0f0"},popup:{background:"#1aa3ff"}},theme:"edgeless"},lightgallery:!0,math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!0,left:"\\begin{equation}",right:"\\end{equation}"},{display:!0,left:"\\begin{equation*}",right:"\\end{equation*}"},{display:!0,left:"\\begin{align}",right:"\\end{align}"},{display:!0,left:"\\begin{align*}",right:"\\end{align*}"},{display:!0,left:"\\begin{alignat}",right:"\\end{alignat}"},{display:!0,left:"\\begin{alignat*}",right:"\\end{alignat*}"},{display:!0,left:"\\begin{gather}",right:"\\end{gather}"},{display:!0,left:"\\begin{CD}",right:"\\end{CD}"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},search:{distance:100,findAllMatches:!1,fuseIndexURL:"/ooooo-notes/index.json",highlightTag:"em",ignoreFieldNorm:!1,ignoreLocation:!1,isCaseSensitive:!1,location:0,maxResultLength:10,minMatchCharLength:2,noResultsFound:"没有找到结果",snippetLength:30,threshold:.3,type:"fuse",useExtendedSearch:!1},twemoji:!0,typeit:{cursorChar:"|",cursorSpeed:1e3,duration:-1,loop:!1,speed:100},version:"v0.3.8-RC"}</script><script src=/ooooo-notes/js/theme.min.js defer></script></body></html>