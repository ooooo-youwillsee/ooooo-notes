<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>随笔 - 合集 - 线偶的IT笔记</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/collections/%E9%9A%8F%E7%AC%94/</link><description>随笔 - 合集 | 线偶的IT笔记</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>297872913@qq.com (线偶)</managingEditor><webMaster>297872913@qq.com (线偶)</webMaster><lastBuildDate>Sun, 24 Mar 2024 08:00:00 +0800</lastBuildDate><atom:link href="https://ooooo-youwillsee.github.io/ooooo-notes/collections/%E9%9A%8F%E7%AC%94/" rel="self" type="application/rss+xml"/><item><title>使用时间轮和线程池实现一个任务执行器</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/%E4%BD%BF%E7%94%A8%E6%97%B6%E9%97%B4%E8%BD%AE%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C%E5%99%A8/</link><pubDate>Sun, 24 Mar 2024 08:00:00 +0800</pubDate><author>线偶</author><guid>https://ooooo-youwillsee.github.io/ooooo-notes/%E4%BD%BF%E7%94%A8%E6%97%B6%E9%97%B4%E8%BD%AE%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C%E5%99%A8/</guid><description>java 的线程池可以充当一个任务执行器的，但是有时候不符合我们的要求，所以需要自定义开发。 满足1：可以根据任务数量来动态调整核心线程数和最大线程数</description></item><item><title>实现一个软引用缓存</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%BD%AF%E5%BC%95%E7%94%A8%E7%BC%93%E5%AD%98/</link><pubDate>Wed, 20 Mar 2024 08:00:00 +0800</pubDate><author>线偶</author><guid>https://ooooo-youwillsee.github.io/ooooo-notes/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%BD%AF%E5%BC%95%E7%94%A8%E7%BC%93%E5%AD%98/</guid><description>在 java 中有四种引用类型，分为强引用，软引用，弱引用，虚引用，这里介绍如何使用软引用来实现一个缓存。 实现代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18</description></item><item><title>缓存一致性问题</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98/</link><pubDate>Sun, 07 Jan 2024 08:00:00 +0800</pubDate><author>线偶</author><guid>https://ooooo-youwillsee.github.io/ooooo-notes/%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98/</guid><description>当我们使用缓存时，必定会遇到缓存一致性问题，也就是在读写请求过程中数据库和缓存中的数据不一致。 下面将分析为什么会造成不一致, 所有的代码参考末</description></item><item><title>mybatis-plus 更新字段为 null 的坑</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/mybatis-plus-%E6%9B%B4%E6%96%B0%E5%AD%97%E6%AE%B5%E4%B8%BA-null-%E7%9A%84%E5%9D%91/</link><pubDate>Tue, 07 Nov 2023 08:00:00 +0800</pubDate><author>线偶</author><guid>https://ooooo-youwillsee.github.io/ooooo-notes/mybatis-plus-%E6%9B%B4%E6%96%B0%E5%AD%97%E6%AE%B5%E4%B8%BA-null-%E7%9A%84%E5%9D%91/</guid><description>字段更新为null的代码 1 2 3 4 5 6 7 8 9 // 实体类字段设置 @TableField(value = &amp;#34;LOCK_EXP_TIME_&amp;#34;, updateStrategy = FieldStrategy.IGNORED) private Date lockExpirationTime; // mapper操作 JobEntity jobEntity = new JobEntity(); jobEntity.setId(1); jobEntity.setLockExpirationTime(null); JobEntityMapper.updateById(jobEntity); 问题上面的操作可能会抛出下面的</description></item><item><title>简单封装 thrift 协议</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/%E7%AE%80%E5%8D%95%E5%B0%81%E8%A3%85-thrift-%E5%8D%8F%E8%AE%AE/</link><pubDate>Wed, 13 Sep 2023 08:00:00 +0800</pubDate><author>线偶</author><guid>https://ooooo-youwillsee.github.io/ooooo-notes/%E7%AE%80%E5%8D%95%E5%B0%81%E8%A3%85-thrift-%E5%8D%8F%E8%AE%AE/</guid><description><![CDATA[build.gradle 文件 1 2 3 4 5 6 7 8 9 10 11 plugins { id(&#34;com.linecorp.thrift-gradle-plugin&#34;) version &#34;0.5.0&#34; } dependencies { api(&#39;org.apache.thrift:libthrift:0.19.0&#39;) api(&#39;org.springframework.boot:spring-boot-starter-logging&#39;) api(&#39;cn.hutool:hutool-all&#39;) testImplementation(&#39;org.springframework.boot:spring-boot-starter-test&#39;) } example.thrift 文件文件放在路径: src/main/thrift, 运行 gradle 命令 compileThrift 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26]]></description></item><item><title>raft 协议重新设置 ip</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/raft-%E5%8D%8F%E8%AE%AE%E9%87%8D%E6%96%B0%E8%AE%BE%E7%BD%AE-ip/</link><pubDate>Fri, 08 Sep 2023 08:00:00 +0800</pubDate><author>线偶</author><guid>https://ooooo-youwillsee.github.io/ooooo-notes/raft-%E5%8D%8F%E8%AE%AE%E9%87%8D%E6%96%B0%E8%AE%BE%E7%BD%AE-ip/</guid><description>raft 节点在机器ip变动之后，可能出现选主不成功的问题。 解决方法下面是 nacos 的 JRaft 解决方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30</description></item><item><title>github 上使用 goreleaser</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/github-%E4%B8%8A%E4%BD%BF%E7%94%A8-goreleaser/</link><pubDate>Tue, 01 Aug 2023 08:00:00 +0800</pubDate><author>线偶</author><guid>https://ooooo-youwillsee.github.io/ooooo-notes/github-%E4%B8%8A%E4%BD%BF%E7%94%A8-goreleaser/</guid><description>1. goreleaser 的简单说明 1 2 3 4 5 6 7 8 9 # install goreleaser brew install goreleaser # init goreleaser, create .goreleaser.yml goreleaser init # available commands goreleaser build --clean goreleaser release --snapshot --clean 2. .goreleaser.yml 示例文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25</description></item><item><title>kafka 的 SASL 认证</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/kafka-%E7%9A%84-sasl-%E8%AE%A4%E8%AF%81/</link><pubDate>Tue, 01 Aug 2023 08:00:00 +0800</pubDate><author>线偶</author><guid>https://ooooo-youwillsee.github.io/ooooo-notes/kafka-%E7%9A%84-sasl-%E8%AE%A4%E8%AF%81/</guid><description><![CDATA[1. 搭建 kafka 环境这里使用 docker 来搭建。 docker-compose.yml 配置如下，客户端端口:9094 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 version: &#34;3&#34; services: kafka: image: &#39;bitnami/kafka:latest&#39; ports: - &#39;9092:9092&#39; - &#39;9094:9094&#39; environment: - KAFKA_CFG_NODE_ID=0 - KAFKA_CFG_PROCESS_ROLES=controller,broker - KAFKA_CFG_LISTENERS=PLAINTEXT://:9092,CONTROLLER://:9093,EXTERNAL://:9094 - KAFKA_CFG_ADVERTISED_LISTENERS=PLAINTEXT://kafka:9092,EXTERNAL://localhost:9094 -]]></description></item><item><title>protocols</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/protocols/</link><pubDate>Mon, 31 Jul 2023 08:00:00 +0800</pubDate><author>线偶</author><guid>https://ooooo-youwillsee.github.io/ooooo-notes/protocols/</guid><description>websocket</description></item><item><title>使用 netty 的注意点</title><link>https://ooooo-youwillsee.github.io/ooooo-notes/%E4%BD%BF%E7%94%A8-netty-%E7%9A%84%E6%B3%A8%E6%84%8F%E7%82%B9/</link><pubDate>Sun, 30 Jul 2023 08:00:00 +0800</pubDate><author>线偶</author><guid>https://ooooo-youwillsee.github.io/ooooo-notes/%E4%BD%BF%E7%94%A8-netty-%E7%9A%84%E6%B3%A8%E6%84%8F%E7%82%B9/</guid><description>1. HttpHelloWorldServerHandler 为啥需要使用 SimpleChannelInboundHandler ?HttpObject 的子类有 LastHttpContent, HttpContent, HttpData， 它需要手动调用 release()。</description></item></channel></rss>